<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Comlink原理解析</title>
      <link href="/2025/12/01/comlink-yuan-li-jie-xi/"/>
      <url>/2025/12/01/comlink-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Comlink-的核心目标：让-Worker-通信像调用本地函数一样"><a href="#Comlink-的核心目标：让-Worker-通信像调用本地函数一样" class="headerlink" title="Comlink 的核心目标：让 Worker 通信像调用本地函数一样"></a>Comlink 的核心目标：让 Worker 通信像调用本地函数一样</h2><h3 id="Conlink-解决了什么问题"><a href="#Conlink-解决了什么问题" class="headerlink" title="Conlink 解决了什么问题"></a>Conlink 解决了什么问题</h3><p>传统 Worker 通信：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"ADD"</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// worker.js</span>onmessage <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> type<span class="token punctuation">,</span> payload <span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'add'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> payload<span class="token punctuation">;</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token function">postMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点：</p><ul><li>需要定义 message type / payload</li><li>数据需要手动封装</li><li>回调地狱</li><li>不能传函数</li><li>不能传对象方法调用</li><li>不支持 await workerFn()</li></ul><p>Comlink 把这两件事自动化：</p><ol><li><strong>通信层抽象成 RPC</strong></li><li><strong>远程对象抽象为本地 Proxy</strong></li></ol><p>所以你调用：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> api <span class="token operator">=</span> Comlink<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>worker<span class="token punctuation">.</span>js<span class="token punctuation">)</span><span class="token keyword">await</span> api<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上等价于：</p><pre class="line-numbers language-js"><code class="language-js">worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">"APPLY"</span><span class="token punctuation">,</span>  path<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"add"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  argumentList<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"RAW"</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"RAW"</span><span class="token punctuation">,</span> valueL<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">await</span> <span class="token function">waitForResponse</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本质是：</p><blockquote><p>Comlink = Proxy 捕获 API 调用 → 自动序列化/transferable，转为 message 发给 worker，返回 Promise → worker 执行 → 把结果打包成消息回传 → 主线程的 Promise resolve， 执行回调函数</p></blockquote><p>github地址：<a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a></p><hr><h2 id="Comlink-组件"><a href="#Comlink-组件" class="headerlink" title="Comlink 组件"></a>Comlink 组件</h2><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>wrap()</code></td><td>将 worker 代理成一个 <code>Proxy</code></td></tr><tr><td><code>expose()</code></td><td>在 worker 中暴露对象</td></tr><tr><td><code>serialize()</code> / <code>deserialize()</code></td><td>转为可跨线程传输的 wire 数据格式</td></tr><tr><td><code>endpoint</code></td><td><code>postMessage</code> + <code>addEventListener</code> 的包装</td></tr><tr><td>object registry</td><td>存远程对象引用（<code>Proxy</code> 句柄）</td></tr><tr><td>request-response map</td><td>用 <code>id</code> 映射 <code>Promise</code></td></tr></tbody></table><hr><h2 id="Comlink-消息协议"><a href="#Comlink-消息协议" class="headerlink" title="Comlink 消息协议"></a>Comlink 消息协议</h2><p>Comlink 使用极小的协议：</p><table><thead><tr><th>type</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>读取属性</td></tr><tr><td>SET</td><td>写属性</td></tr><tr><td>APPLY</td><td>调用函数</td></tr><tr><td>CONSTRUCT</td><td>new</td></tr><tr><td>RELEASE</td><td>删除远程对象</td></tr></tbody></table><p>一个函数调用最终会生成：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">"APPLY"</span><span class="token punctuation">,</span>  callPath<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"database"</span><span class="token punctuation">,</span> <span class="token string">"query"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  argumentList<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"RAW"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">:</span> <span class="token number">18</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span>  id<span class="token punctuation">:</span> <span class="token string">"req-xxxx"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker 执行后：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">"RESULT"</span><span class="token punctuation">,</span>  id<span class="token punctuation">:</span> <span class="token string">"req-xxxx"</span><span class="token punctuation">,</span>  result<span class="token punctuation">:</span> <span class="token number">123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="wrap-原理-–-利用-Proxy-拦截所有操作"><a href="#wrap-原理-–-利用-Proxy-拦截所有操作" class="headerlink" title="wrap() 原理 – 利用 Proxy 拦截所有操作"></a>wrap() 原理 – 利用 Proxy 拦截所有操作</h2><p>wrap(worker) 返回 Proxy：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> api <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Proxy 拦截三种操作：</p><ul><li>get → 读取属性</li><li>set → 设置属性</li><li>apply → 调用函数</li></ul><p>核心伪代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createProxy</span><span class="token punctuation">(</span>endPointer<span class="token punctuation">,</span> path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>endPointer<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token keyword">get</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> prop<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 一些处理 ...</span>      <span class="token keyword">return</span> <span class="token function">createProxy</span><span class="token punctuation">(</span>endPointer<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>path<span class="token punctuation">,</span> prop<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">apply</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 一些处理 ...</span>      <span class="token keyword">return</span> <span class="token function">requestResponseMessage</span><span class="token punctuation">(</span><span class="token string">"APPLY"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Promise</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">set</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 一些处理 ...</span>      <span class="token keyword">return</span> <span class="token function">requestResponseMessage</span><span class="token punctuation">(</span><span class="token string">"SET"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>path<span class="token punctuation">,</span> props<span class="token punctuation">]</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Promise</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>“读取属性”只是构建 path，不会通信</li><li>“调用函数”才真正发消息</li></ul><hr><h2 id="expose-原理"><a href="#expose-原理" class="headerlink" title="expose()原理"></a>expose()原理</h2><p>Worker 端暴露对象：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> exposedObject <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token punctuation">}</span><span class="token punctuation">}</span>Comlink<span class="token punctuation">.</span><span class="token function">expose</span><span class="token punctuation">(</span>exposedObject<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>expose 会监听消息：</p><pre class="line-numbers language-js"><code class="language-js">onmessage <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> id<span class="token punctuation">,</span> type<span class="token punctuation">,</span> path<span class="token punctuation">,</span> argumentList <span class="token punctuation">}</span> <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token keyword">const</span> target <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> o<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> exposedObject<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"APPLY"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>argumentList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    endpoint<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token string">"RESULT"</span><span class="token punctuation">,</span> result <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流程非常简单：</p><ul><li>根据 path 找到被调用的函数</li><li>调用函数</li><li>把结果返回</li></ul><hr><h2 id="参数-amp-返回值序列化机制"><a href="#参数-amp-返回值序列化机制" class="headerlink" title="参数 &amp; 返回值序列化机制"></a>参数 &amp; 返回值序列化机制</h2><p>Comlink 强化了结构化克隆：</p><table><thead><tr><th>Input</th><th align="center">Output</th><th>Notes</th></tr></thead><tbody><tr><td><code>[1,2,3]</code></td><td align="center"><code>[1,2,3]</code></td><td>Full copy</td></tr><tr><td><code>{a: 1, b: 2}</code></td><td align="center"><code>{a: 1, b: 2}</code></td><td>Full copy</td></tr><tr><td><code>{a: 1, b() { return 2; }</code></td><td align="center"><code>{a: 1}</code></td><td>Full copy, 忽略 functions</td></tr><tr><td><code>new MyClass()</code></td><td align="center"><code>{...}</code></td><td>仅仅包含 properties</td></tr><tr><td><code>Map</code></td><td align="center"><code>Map</code></td><td>[<code>Map</code>][map] 是 structured cloneable</td></tr><tr><td><code>Set</code></td><td align="center"><code>Set</code></td><td>[<code>Set</code>][set] 是 structured cloneable</td></tr><tr><td><code>ArrayBuffer</code></td><td align="center"><code>ArrayBuffer</code></td><td>[<code>ArrayBuffer</code>][arraybuffer] 是 structured cloneable</td></tr><tr><td><code>Uint32Array</code></td><td align="center"><code>Uint32Array</code></td><td>[<code>Uint32Array</code>][uint32array] 以及所有其他 type 的数组都是 structured cloneable</td></tr><tr><td><code>Event</code></td><td align="center">❌</td><td></td></tr><tr><td>Any DOM element</td><td align="center">❌</td><td></td></tr><tr><td><code>MessagePort</code></td><td align="center">❌</td><td>仅能 transferable, 不是 structured cloneable</td></tr><tr><td><code>Request</code></td><td align="center">❌</td><td></td></tr><tr><td><code>Response</code></td><td align="center">❌</td><td></td></tr><tr><td><code>ReadableStream</code></td><td align="center">❌</td><td>[Streams are planned to be transferable][transferable streams], 不是 structured cloneable</td></tr></tbody></table><hr><h2 id="Promise-实现（request-response）"><a href="#Promise-实现（request-response）" class="headerlink" title="Promise 实现（request-response）"></a>Promise 实现（request-response）</h2><p>wrap 调用远程方法时：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> msgId <span class="token operator">=</span> <span class="token function">generateId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>endpoint<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    pendingMap<span class="token punctuation">[</span>msgId<span class="token punctuation">]</span> <span class="token operator">=</span> resolve<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主线程中维护一个 Map：</p><pre class="line-numbers language-js"><code class="language-js">pendingRequests<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Worker 返回时：</p><pre class="line-numbers language-js"><code class="language-js">endpoint<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> type<span class="token punctuation">:</span><span class="token string">"RESULT"</span><span class="token punctuation">,</span> result <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主线程收到：</span>pendingMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">delete</span> pendingMap<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> WebWorker </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebWorker原理详解</title>
      <link href="/2025/12/01/webworker-yuan-li-jie-xi/"/>
      <url>/2025/12/01/webworker-yuan-li-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>WebWorker 作为浏览器提供的多线程解决方案，为前端开发者带来了突破JavaScript单线程限制的能力。本文将从原理到实践，全面解析WebWorker的核心概念与应用场景。</p><h2 id="1-到底什么是WebWorker"><a href="#1-到底什么是WebWorker" class="headerlink" title="1. 到底什么是WebWorker"></a>1. 到底什么是WebWorker</h2><p>WebWorker是HTML5标准的一部分，允许在后台线程中运行JavaScript脚本，而不会阻塞用户界面。它为JavaScript提供了真正的多线程能力，使得CPU密集型任务可以在独立的线程中执行。</p><h3 id="核心特性："><a href="#核心特性：" class="headerlink" title="核心特性："></a>核心特性：</h3><ul><li><strong>后台执行</strong>：在独立线程中运行，不影响主线程UI渲染</li><li><strong>并行计算</strong>：支持真正的多线程并行处理</li><li><strong>消息通信</strong>：通过postMessage/onmessage机制与主线程通信</li><li><strong>标准化支持</strong>：现代浏览器普遍支持</li></ul><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/worker%E5%88%86%E7%B1%BB.png"></p><h3 id="Dedicated-Worker（专用Worker）"><a href="#Dedicated-Worker（专用Worker）" class="headerlink" title="Dedicated Worker（专用Worker）"></a>Dedicated Worker（专用Worker）</h3><ul><li><strong>一对一关系</strong>：每个Worker实例只能被一个页面使用</li><li><strong>独立作用域</strong>：拥有独立的全局作用域DedicatedWorkerGlobalScope</li><li><strong>资源隔离</strong>：内存和执行环境完全隔离</li></ul><h3 id="Shared-Worker（共享Worker）"><a href="#Shared-Worker（共享Worker）" class="headerlink" title="Shared Worker（共享Worker）"></a>Shared Worker（共享Worker）</h3><ul><li><strong>一对多关系</strong>：可以被多个页面或iframe共享</li><li><strong>共享作用域</strong>：使用SharedWorkerGlobalScope</li><li><strong>端口通信</strong>：通过MessagePort进行通信</li><li><strong>浏览器支持</strong>：部分浏览器支持有限</li></ul><h3 id="Service-Worker（服务Worker）"><a href="#Service-Worker（服务Worker）" class="headerlink" title="Service Worker（服务Worker）"></a>Service Worker（服务Worker）</h3><p>  这是一个更特殊、更强大的 Worker, 它本质上是一个位于浏览器和网络之间的<strong>事件驱动的可编程网络代理</strong></p><ul><li><strong>独立生命周期</strong>：它的生命周期与页面完全无关，即使用户关闭了所有相关页面，它也可以在后台运行</li><li><strong>无法访问DOM</strong>：和所有 Worker 一样</li><li><strong>拦截网络请求</strong>：可以拦截、处理和响应作用域内的所有网络请求</li><li><strong>核心能力</strong>：是实现<strong>渐进式网络应用（PWA）</strong>的核心技术，能够带来丰富的原生应用体验，如<strong>离线缓存、消息推送</strong>等。</li></ul><h2 id="3-三独立、一限制"><a href="#3-三独立、一限制" class="headerlink" title="3. 三独立、一限制"></a>3. 三独立、一限制</h2><p>要理解 Worker，就要理解它的运行环境。每个 Worker 都拥有一个与住县城完全隔离的、独立的运行环境。具体变现为：</p><h3 id="三独立："><a href="#三独立：" class="headerlink" title="三独立："></a>三独立：</h3><ul><li><strong>独立的全局对象</strong>：主线程全局对象是 <code>window</code>, 而在 Worker 线程中，全局对象是 <code>self</code> 或 <code>this</code>。你无法在 Worker 中访问 <code>window</code> 对象</li><li><strong>独立的内存空间</strong>：内存与主线程不共享，有自己的内存堆栈</li><li><strong>独立的事件循环</strong>：有自己的事件循环机制，可以使用部分 Web API, 如 <code>setTimeout</code>、<code>setInterval</code>、<code>fetch</code> 等</li></ul><h3 id="一限制："><a href="#一限制：" class="headerlink" title="一限制："></a>一限制：</h3><ul><li><strong>无法访问DOM</strong>：UI相关API受限，不能使用alert、localStorage等浏览器API</li></ul><h2 id="4-主线程与Worker通信机制"><a href="#4-主线程与Worker通信机制" class="headerlink" title="4. 主线程与Worker通信机制"></a>4. 主线程与Worker通信机制</h2><h3 id="4-1-基本通信模式"><a href="#4-1-基本通信模式" class="headerlink" title="4.1 基本通信模式"></a>4.1 基本通信模式</h3><p>WebWorker采用消息传递机制进行通信：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 主线程</span><span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token string">'worker.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>cmd<span class="token punctuation">:</span> <span class="token string">'start'</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'收到结果:'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// worker.js</span>self<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>cmd<span class="token punctuation">,</span> data<span class="token punctuation">}</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd <span class="token operator">===</span> <span class="token string">'start'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">processData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-通信数据类型"><a href="#4-2-通信数据类型" class="headerlink" title="4.2 通信数据类型"></a>4.2 通信数据类型</h3><ul><li><strong>支持的数据类型</strong>：基本类型、对象、数组</li><li><strong>序列化机制</strong>：使用结构化克隆算法</li><li><strong>传输限制</strong>：不支持函数、DOM元素等不可序列化对象</li></ul><h3 id="4-3-错误处理"><a href="#4-3-错误处理" class="headerlink" title="4.3 错误处理"></a>4.3 错误处理</h3><pre class="line-numbers language-javascript"><code class="language-javascript">worker<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Worker错误:'</span><span class="token punctuation">,</span> error<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span>onmessageerror <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'消息错误:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-数据传输的性能瓶颈与优化"><a href="#5-数据传输的性能瓶颈与优化" class="headerlink" title="5. 数据传输的性能瓶颈与优化"></a>5. 数据传输的性能瓶颈与优化</h2><h3 id="5-1-性能瓶颈"><a href="#5-1-性能瓶颈" class="headerlink" title="5.1 性能瓶颈"></a>5.1 性能瓶颈</h3><h4 id="序列化开销"><a href="#序列化开销" class="headerlink" title="序列化开销"></a>序列化开销</h4><ul><li>数据需要序列化/反序列化，存在时间成本</li><li>大对象的拷贝会造成内存翻倍</li><li>频繁通信会影响性能</li></ul><h4 id="内存拷贝"><a href="#内存拷贝" class="headerlink" title="内存拷贝"></a>内存拷贝</h4><ul><li>默认采用深拷贝方式传输数据</li><li>大量数据传输时内存占用显著增加</li></ul><h3 id="5-2-优化策略"><a href="#5-2-优化策略" class="headerlink" title="5.2 优化策略"></a>5.2 优化策略</h3><h4 id="5-2-1-Transferable-Objects"><a href="#5-2-1-Transferable-Objects" class="headerlink" title="5.2.1 Transferable Objects"></a>5.2.1 Transferable Objects</h4><p>使用可转移对象避免数据拷贝：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 转移ArrayBuffer所有权</span><span class="token keyword">const</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token punctuation">[</span>buffer<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 主线程中buffer变为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-2-数据分块处理"><a href="#5-2-2-数据分块处理" class="headerlink" title="5.2.2 数据分块处理"></a>5.2.2 数据分块处理</h4><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 大数据分块传输</span><span class="token keyword">function</span> <span class="token function">sendLargeData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> chunkSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> chunkSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> chunk <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> chunkSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token punctuation">:</span> <span class="token string">'chunk'</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> chunk<span class="token punctuation">,</span> index<span class="token punctuation">:</span> i<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-3-减少通信频率"><a href="#5-2-3-减少通信频率" class="headerlink" title="5.2.3 减少通信频率"></a>5.2.3 减少通信频率</h4><ul><li>批量处理消息</li><li>使用节流/防抖控制消息频率</li><li>合理设计通信协议</li></ul><h2 id="6-常见业务开发实践场景"><a href="#6-常见业务开发实践场景" class="headerlink" title="6. 常见业务开发实践场景"></a>6. 常见业务开发实践场景</h2><h3 id="大数据计算"><a href="#大数据计算" class="headerlink" title="大数据计算"></a>大数据计算</h3><ul><li><strong>数据排序</strong>：大量数据的排序算法</li><li><strong>统计分析</strong>：复杂的数据统计和分析</li><li><strong>数学计算</strong>：矩阵运算、科学计算</li></ul><h3 id="图像-视频处理"><a href="#图像-视频处理" class="headerlink" title="图像/视频处理"></a>图像/视频处理</h3><ul><li><strong>图像滤镜</strong>：图像像素级处理</li><li><strong>视频解码</strong>：视频帧处理</li><li><strong>图像压缩</strong>：图像格式转换和压缩</li></ul><h3 id="网络请求处理"><a href="#网络请求处理" class="headerlink" title="网络请求处理"></a>网络请求处理</h3><ul><li><strong>数据预加载</strong>：后台预取数据</li><li><strong>定时任务</strong>：定期数据同步</li><li><strong>文件上传</strong>：大文件分片上传</li></ul><h3 id="算法密集型任务"><a href="#算法密集型任务" class="headerlink" title="算法密集型任务"></a>算法密集型任务</h3><ul><li><strong>加密解密</strong>：数据加密处理</li><li><strong>哈希计算</strong>：大量哈希运算</li><li><strong>搜索算法</strong>：复杂搜索逻辑</li></ul><h2 id="7-进阶实践"><a href="#7-进阶实践" class="headerlink" title="7. 进阶实践"></a>7. 进阶实践</h2><h3 id="7-1-Worker线程池"><a href="#7-1-Worker线程池" class="headerlink" title="7.1 Worker线程池"></a>7.1 Worker线程池</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">WorkerPool</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>workerScript<span class="token punctuation">,</span> poolSize <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>taskQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>busyWorkers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> poolSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>workers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>workerScript<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token function">execute</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token punctuation">{</span>data<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAvailableWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>worker<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">executeTask</span><span class="token punctuation">(</span>worker<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>taskQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-使用成熟的库"><a href="#7-2-使用成熟的库" class="headerlink" title="7.2 使用成熟的库"></a>7.2 使用成熟的库</h3><p>可以了解下 GoogleChrome Labs 出品的 <a href="https://github.com/GoogleChromeLabs/comlink">Comlink</a> 库，它通过 Proxy 和 Promise 极大的简化了 Worker 的使用，让你几乎感觉不到 postMessage 的存在，详情可以参考<a href="https://mrw1108.github.io/2025/12/01/comlink-yuan-li-jie-xi/">Comlink原理解析</a></p><h3 id="7-3-Worker与SharedArrayBuffer"><a href="#7-3-Worker与SharedArrayBuffer" class="headerlink" title="7.3 Worker与SharedArrayBuffer"></a>7.3 Worker与SharedArrayBuffer</h3><p>在支持的环境中，可以使用SharedArrayBuffer实现真正的内存共享。</p><h3 id="7-4-Worker监控与调试"><a href="#7-4-Worker监控与调试" class="headerlink" title="7.4 Worker监控与调试"></a>7.4 Worker监控与调试</h3><ul><li>使用Chrome DevTools调试Worker</li><li>实现Worker性能监控</li><li>错误日志收集与分析</li></ul><h2 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8. 注意事项"></a>8. 注意事项</h2><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><ul><li><strong>主流浏览器支持</strong>：现代浏览器普遍支持 Dedicated Worker</li><li><strong>Shared Worker限制</strong>：Safari等浏览器支持有限</li><li><strong>移动端差异</strong>：部分移动浏览器可能有限制</li></ul><h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><ul><li><strong>同源策略</strong>：Worker脚本必须遵循同源策略</li><li><strong>CSP限制</strong>：Content Security Policy可能影响Worker创建</li><li><strong>HTTPS要求</strong>：某些功能可能要求HTTPS环境</li></ul><h3 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h3><ul><li><strong>创建成本</strong>：Worker创建有一定开销，不适合短任务</li><li><strong>内存使用</strong>：每个Worker占用独立内存空间</li><li><strong>线程数量</strong>：避免创建过多Worker导致资源竞争</li></ul><h3 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h3><ul><li><strong>调试工具</strong>：Chrome DevTools支持Worker调试</li><li><strong>错误处理</strong>：完善的错误处理机制</li><li><strong>日志记录</strong>：合理的日志记录策略</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><strong>任务适配</strong>：选择合适的任务使用Worker</li><li><strong>生命周期管理</strong>：及时终止不需要的Worker</li><li><strong>资源清理</strong>：避免内存泄漏</li><li><strong>降级策略</strong>：为不支持Worker的环境准备降级方案</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WebWorker作为前端多线程解决方案，在处理CPU密集型任务时具有显著优势。理解其”三独立、一限制”的设计原则，掌握高效的通信机制和性能优化策略，能够让我们在复杂的前端应用中充分发挥多线程的能力。</p><p>在实际应用中，需要权衡任务特性、性能需求和开发复杂度，选择最适合的实现方案。随着浏览器技术的发展，WebWorker将在前端性能优化中发挥越来越重要的作用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> WebWorker </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 TensorFlow.js 的前端分类AI系统</title>
      <link href="/2025/09/25/ji-yu-tensorflow.js-de-qian-duan-fen-lei-ai-xi-tong/"/>
      <url>/2025/09/25/ji-yu-tensorflow.js-de-qian-duan-fen-lei-ai-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="基于-TensorFlow-js-的前端分类-AI-系统"><a href="#基于-TensorFlow-js-的前端分类-AI-系统" class="headerlink" title="基于 TensorFlow.js 的前端分类 AI 系统"></a>基于 TensorFlow.js 的前端分类 AI 系统</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近工作中实现了一个需求：Scratch 积木编程实现分类 AI 功能，包括数据处理、神经网络训练、根据模型预测结果和可视化功能。记录一下前端基于 TensorFlow.js 的实现思路。</p><h2 id="详细步骤说明"><a href="#详细步骤说明" class="headerlink" title="详细步骤说明"></a>详细步骤说明</h2><h3 id="1-数据准备阶段"><a href="#1-数据准备阶段" class="headerlink" title="1. 数据准备阶段"></a>1. 数据准备阶段</h3><pre class="mermaid">flowchart LR    A[原始数据] --&gt; B[数据清洗]    B --&gt; C[格式转换]    C --&gt; D[特征提取]    D --&gt; E[标签编码]    B1[去除缺失值] --&gt; B    B2[去除异常值] --&gt; B    B3[数据去重] --&gt; B    C1[数组格式化] --&gt; C    C2[数据类型转换] --&gt; C    D1[特征选择] --&gt; D    D2[特征缩放] --&gt; D    D3[特征组合] --&gt; D    E1[One-Hot编码] --&gt; E    E2[标签映射] --&gt; E</pre><h3 id="2-模型构建阶段"><a href="#2-模型构建阶段" class="headerlink" title="2. 模型构建阶段"></a>2. 模型构建阶段</h3><pre class="mermaid">flowchart TD    A[确定问题类型] --&gt; B{分类还是回归?}    B --&gt;|分类| C[选择分类模型]    B --&gt;|回归| D[选择回归模型]    C --&gt; C1[神经网络]    C --&gt; C2[决策树]    C --&gt; C3[SVM]    C --&gt; C4[随机森林]    D --&gt; D1[线性回归]    D --&gt; D2[神经网络]    D --&gt; D3[决策树]    C1 --&gt; E[设计网络架构]    C2 --&gt; F[设置参数]    C3 --&gt; F    C4 --&gt; F    D1 --&gt; F    D2 --&gt; E    D3 --&gt; F    E --&gt; G[输入层设计]    E --&gt; H[隐藏层设计]    E --&gt; I[输出层设计]    G --&gt; J[编译模型]    H --&gt; J    I --&gt; J    F --&gt; J</pre><h3 id="3-训练优化循环"><a href="#3-训练优化循环" class="headerlink" title="3. 训练优化循环"></a>3. 训练优化循环</h3><pre class="mermaid">flowchart TD    A[初始化模型] --&gt; B[设置训练参数]    B --&gt; C[开始训练]    C --&gt; D[前向传播]    D --&gt; E[计算损失]    E --&gt; F[反向传播]    F --&gt; G[更新权重]    G --&gt; H[记录指标]    H --&gt; I{达到停止条件?}    I --&gt;|否| J[下一个批次]    J --&gt; D    I --&gt;|是| K[训练完成]    B --&gt; B1[学习率]    B --&gt; B2[批次大小]    B --&gt; B3[训练轮数]    B --&gt; B4[优化器]    I --&gt; I1[最大轮数]    I --&gt; I2[早停条件]    I --&gt; I3[收敛判断]    style C fill:#f3e5f5    style K fill:#e8f5e8</pre><h2 id="项目的具体实现流程"><a href="#项目的具体实现流程" class="headerlink" title="项目的具体实现流程"></a>项目的具体实现流程</h2><pre class="mermaid">flowchart TD    A[用户输入特征数据excel] --&gt; B[setTrainingFeatures<br>数据格式转换]    B --&gt; C[用户输入分类标签数据] --&gt; D[setTrainingLabels<br>标签处理]    D --&gt; E[用户配置网络结构] --&gt; F[initializeModel<br>模型初始化]    F --&gt; G[trainModel<br>开始训练]    G --&gt; G1[创建Sequential模型]    G1 --&gt; G2[添加Dense层]    G2 --&gt; G3[模型编译<br>Adam + CrossEntropy]    G3 --&gt; G4[数据张量化]    G4 --&gt; G5[One-Hot编码]    G5 --&gt; G6[model.fit训练]    G6 --&gt; G7[训练回调]    G7 --&gt; G8[更新可视化]    G8 --&gt; G9[训练完成]    G9 --&gt; H[predictWithModel<br>模型预测]    H --&gt; I[输出预测结果]    style G fill:#f3e5f5    style I fill:#e8f5e8</pre><h2 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h2><h3 id="核心技术栈"><a href="#核心技术栈" class="headerlink" title="核心技术栈"></a>核心技术栈</h3><ul><li><strong>TensorFlow.js</strong>: 提供深度学习能力</li><li><strong>D3.js</strong>: 实现数据可视化</li><li><strong>Canvas API</strong>: 渲染决策边界</li></ul><h3 id="系统组件架构"><a href="#系统组件架构" class="headerlink" title="系统组件架构"></a>系统组件架构</h3><pre class="line-numbers language-typescript"><code class="language-typescript">type Data <span class="token operator">=</span> <span class="token punctuation">{</span>  currentGenerationIndex<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前训练次数</span>  features<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 训练特征矩阵</span>  labels<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 训练标签</span>  classLabels<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分类枚举</span>  tempModelMap<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模型存储</span>    <span class="token punctuation">[</span>modelId<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> tf<span class="token punctuation">.</span>Sequential<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  probabilities<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 预测概率</span>  classification<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 预测结果</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心功能实现"><a href="#核心功能实现" class="headerlink" title="核心功能实现"></a>核心功能实现</h2><h3 id="1-智能数据预处理"><a href="#1-智能数据预处理" class="headerlink" title="1. 智能数据预处理"></a>1. 智能数据预处理</h3><p>系统支持灵活的特征数据输入，自动处理列式到行式的数据转换：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token function">setTrainingFeatures</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> BlockArgument<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> dynamicArgs <span class="token operator">=</span> getDynamicArgs<span class="token operator">&lt;</span><span class="token keyword">typeof</span> args<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token string">'FEATURES_'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> featuresList <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>dynamicArgs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_features <span class="token operator">=</span><span class="token operator">></span>    <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>_features<span class="token punctuation">)</span> <span class="token operator">?</span> _features <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">Number</span><span class="token punctuation">(</span>_features<span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将列式存储的特征转换为行式存储 [feature1_array, feature2_array] → [[sample1_f1, sample1_f2], ...]</span>  <span class="token comment" spellcheck="true">// [5.1, 4.9, 5.9], [3.5, 3, 3] => [[5.1, 3.5],[4.9, 3.0],[5.9, 3.0]]</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>blockData<span class="token punctuation">.</span>features <span class="token operator">=</span> featuresList<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>    featuresList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>arr <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Number</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-可配置神经网络架构"><a href="#2-可配置神经网络架构" class="headerlink" title="2. 可配置神经网络架构"></a>2. 可配置神经网络架构</h3><p>系统允许用户自定义网络结构，支持多隐藏层配置：</p><pre class="line-numbers language-typescript"><code class="language-typescript">async <span class="token function">trainModel</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> <span class="token punctuation">{</span> MODEL<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> model <span class="token operator">=</span> tf<span class="token punctuation">.</span><span class="token function">sequential</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输入层 - 自适应特征维度</span>  model<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span><span class="token function">dense</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    units<span class="token punctuation">:</span> features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 神经元为特征数量的两倍</span>    inputShape<span class="token punctuation">:</span> <span class="token punctuation">[</span>features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">,</span>    activation<span class="token punctuation">:</span> <span class="token string">'relu'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 隐藏层 - 用户可配置</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hiddenSizes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    model<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span><span class="token function">dense</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      units<span class="token punctuation">:</span> hiddenSizes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>      activation<span class="token punctuation">:</span> <span class="token string">'relu'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 输出层 - 自适应类别数</span>  model<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>layers<span class="token punctuation">.</span><span class="token function">dense</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    units<span class="token punctuation">:</span> classLabels<span class="token punctuation">.</span>length<span class="token punctuation">,</span>    activation<span class="token punctuation">:</span> <span class="token string">'softmax'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键特性：</strong></p><ul><li>动态网络结构：根据输入特征和输出类别自适应</li><li>ReLU 激活函数：解决梯度消失问题</li><li>Softmax 输出：多分类概率分布</li></ul><h3 id="3-高效训练流程"><a href="#3-高效训练流程" class="headerlink" title="3. 高效训练流程"></a>3. 高效训练流程</h3><p>采用现代深度学习最佳实践：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 模型编译</span>model<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  optimizer<span class="token punctuation">:</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span><span class="token function">adam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// Adam优化器</span>  loss<span class="token punctuation">:</span> <span class="token string">"categoricalCrossentropy"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 多分类损失函数</span>  metrics<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"accuracy"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 准确率监控</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// One-Hot编码</span><span class="token keyword">const</span> label2Index <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>classLabels<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> ys <span class="token operator">=</span> tf<span class="token punctuation">.</span><span class="token function">oneHot</span><span class="token punctuation">(</span>  tf<span class="token punctuation">.</span><span class="token function">tensor1d</span><span class="token punctuation">(</span>    labels<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> label2Index<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">"int32"</span>  <span class="token punctuation">)</span><span class="token punctuation">,</span>  classLabels<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 训练执行</span>await model<span class="token punctuation">.</span><span class="token function">fit</span><span class="token punctuation">(</span>xs<span class="token punctuation">,</span> ys<span class="token punctuation">,</span> <span class="token punctuation">{</span>  epochs<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  verbose<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  shuffle<span class="token punctuation">:</span> <span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 样本随机打乱，提高收敛</span>  validationSplit<span class="token punctuation">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span>  callbacks<span class="token punctuation">:</span> <span class="token punctuation">{</span>    onEpochEnd<span class="token punctuation">:</span> <span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> logs<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 实时可视化更新</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateVisualization</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> epoch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-智能预测系统"><a href="#4-智能预测系统" class="headerlink" title="4. 智能预测系统"></a>4. 智能预测系统</h3><p>结果预测</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token function">predictWithModel</span><span class="token punctuation">(</span>args<span class="token punctuation">:</span> BlockArgument<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> inputFeatures <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>dynamicArgs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>feature <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Number</span><span class="token punctuation">(</span>feature<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> predictions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>blockData<span class="token punctuation">.</span>tempModelMap<span class="token punctuation">[</span>args<span class="token punctuation">.</span>MODEL<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">predict</span><span class="token punctuation">(</span>    tf<span class="token punctuation">.</span><span class="token function">tensor2d</span><span class="token punctuation">(</span><span class="token punctuation">[</span>inputFeatures<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span> as tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">;</span>  <span class="token keyword">const</span> probabilities <span class="token operator">=</span> predictions<span class="token punctuation">.</span><span class="token function">dataSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每个结果的概率</span>  <span class="token keyword">const</span> maxIndex <span class="token operator">=</span> probabilities<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>probabilities<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> classification <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>blockData<span class="token punctuation">.</span>classLabels<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>blockData<span class="token punctuation">.</span>probabilities <span class="token operator">=</span> <span class="token keyword">Array</span><span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>probabilities<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>blockData<span class="token punctuation">.</span>classification <span class="token operator">=</span> classification<span class="token punctuation">;</span>  predictions<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 内存管理</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可视化系统"><a href="#可视化系统" class="headerlink" title="可视化系统"></a>可视化系统</h2><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83.png" alt="alt text"></p><h3 id="1-训练数据散点图"><a href="#1-训练数据散点图" class="headerlink" title="1. 训练数据散点图"></a>1. 训练数据散点图</h3><p>使用 D3.js 创建交互式散点图：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token function">drawScatterPlot</span><span class="token punctuation">(</span>options<span class="token punctuation">:</span> <span class="token punctuation">{</span>  features<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  labels<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  classLabels<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> svg <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'svg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> color <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">scaleOrdinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span>classLabels<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>d3<span class="token punctuation">.</span>schemeCategory10<span class="token punctuation">)</span><span class="token punctuation">;</span>  svg<span class="token punctuation">.</span><span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token string">'circle'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>features<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> labels<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'circle'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'cx'</span><span class="token punctuation">,</span> d <span class="token operator">=</span><span class="token operator">></span> <span class="token function">xScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'cy'</span><span class="token punctuation">,</span> d <span class="token operator">=</span><span class="token operator">></span> <span class="token function">yScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'fill'</span><span class="token punctuation">,</span> d <span class="token operator">=</span><span class="token operator">></span> <span class="token function">color</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-实时决策边界渲染"><a href="#2-实时决策边界渲染" class="headerlink" title="2. 实时决策边界渲染"></a>2. 实时决策边界渲染</h3><p>通过 Canvas API 实现高性能决策边界可视化：</p><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token function">drawDecisionBoundary</span><span class="token punctuation">(</span>options<span class="token punctuation">:</span> <span class="token punctuation">{</span> model<span class="token punctuation">:</span> tf<span class="token punctuation">.</span>Sequential <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> canvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> ctx <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 批量预测网格点</span>  <span class="token keyword">const</span> allInputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> py <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> py <span class="token operator">&lt;</span> plotHeight<span class="token punctuation">;</span> py<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> px <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> px <span class="token operator">&lt;</span> plotWidth<span class="token punctuation">;</span> px<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> fx <span class="token operator">=</span> xScale<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span>px <span class="token operator">+</span> margin<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> fy <span class="token operator">=</span> yScale<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span>py <span class="token operator">+</span> margin<span class="token punctuation">.</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>      allInputs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fx<span class="token punctuation">,</span> fy<span class="token punctuation">,</span> <span class="token operator">...</span>featureMeans<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 一次性推理优化性能</span>  <span class="token keyword">const</span> inputTensor <span class="token operator">=</span> tf<span class="token punctuation">.</span><span class="token function">tensor2d</span><span class="token punctuation">(</span>allInputs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> probsTensor <span class="token operator">=</span> model<span class="token punctuation">.</span><span class="token function">predict</span><span class="token punctuation">(</span>inputTensor<span class="token punctuation">)</span> as tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">;</span>  <span class="token keyword">const</span> probsArr <span class="token operator">=</span> probsTensor<span class="token punctuation">.</span><span class="token function">dataSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 渲染像素</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renderDecisionBoundaryImage</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> classIndexMatrix<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="系统优势"><a href="#系统优势" class="headerlink" title="系统优势"></a>系统优势</h2><ul><li><strong>直观可视化</strong>: 实时展示训练过程和决策边界</li><li><strong>模块化设计</strong>: 每个功能独立，便于理解</li><li><strong>即时反馈</strong>: 训练和预测结果立即可见</li><li><strong>前端 AI</strong>: 完全在浏览器中运行，无需服务器</li></ul><h2 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 及时释放张量资源</span>xs<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ys<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>predictions<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-批量处理"><a href="#2-批量处理" class="headerlink" title="2. 批量处理"></a>2. 批量处理</h3><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 批量预测替代逐点预测</span><span class="token keyword">const</span> inputTensor <span class="token operator">=</span> tf<span class="token punctuation">.</span><span class="token function">tensor2d</span><span class="token punctuation">(</span>allInputs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> probsTensor <span class="token operator">=</span> model<span class="token punctuation">.</span><span class="token function">predict</span><span class="token punctuation">(</span>inputTensor<span class="token punctuation">)</span> as tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-Canvas-优化"><a href="#3-Canvas-优化" class="headerlink" title="3. Canvas 优化"></a>3. Canvas 优化</h3><pre class="line-numbers language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// 预缓存颜色避免重复计算</span><span class="token keyword">const</span> colorCache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> c <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">color</span><span class="token punctuation">(</span><span class="token function">color</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> colorCache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>c<span class="token punctuation">.</span>r<span class="token punctuation">,</span> c<span class="token punctuation">.</span>g<span class="token punctuation">,</span> c<span class="token punctuation">.</span>b<span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elpis 学习心得</title>
      <link href="/2025/06/19/elpis-xue-xi-xin-de/"/>
      <url>/2025/06/19/elpis-xue-xi-xin-de/</url>
      
        <content type="html"><![CDATA[<h1 id="Elpis-学习心得"><a href="#Elpis-学习心得" class="headerlink" title="Elpis 学习心得"></a>Elpis 学习心得</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="1-1-当前大多数前端开发的痛点"><a href="#1-1-当前大多数前端开发的痛点" class="headerlink" title="1.1 当前大多数前端开发的痛点"></a>1.1 当前大多数前端开发的痛点</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/1-elpis.png"> 随着前端框架的成熟，开发者们越来越多地陷入了重复的 CRUD 工作中，忽略了程序员的本质：7 分构想，3 分代码。Elpis 的出现，旨在分享一种思想：通过 80% 的抽离和重复工作支持配置化，20% 的定制化工作，减少 CRUD 体力活的比例，让程序员更专注于创造。</p><h3 id="1-2-庞大且功能全的系统"><a href="#1-2-庞大且功能全的系统" class="headerlink" title="1.2 庞大且功能全的系统"></a>1.2 庞大且功能全的系统</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/2-elpis.png"> 缺点：</p><ul><li>项目体积大</li><li>不适合<strong>多用户</strong>交付场景</li><li>交付时候，可能会包含<strong>无用的代码</strong></li><li>定制化能力弱，往往<strong>需要用户妥协</strong></li><li>系统迭代 <strong>熵增明显</strong></li></ul><h3 id="1-3-多子系统：类似微前端"><a href="#1-3-多子系统：类似微前端" class="headerlink" title="1.3 多子系统：类似微前端"></a>1.3 多子系统：类似微前端</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/3-elpis.png"> 缺点：</p><ul><li>通用的建站能力不适合<strong>领域强的场景</strong></li><li>过分灵活，配置复杂，<strong>若处理不好容易代码断代，此时对提效没有实质的提高，反而成了负担</strong></li><li>不能体系化触达到领域问题</li></ul><h3 id="1-4-elpis思想"><a href="#1-4-elpis思想" class="headerlink" title="1.4 elpis思想"></a>1.4 elpis思想</h3><p>融合前面所提到的庞大系统（不灵活），多个子系统（过分灵活）的特点，用折中的方案去优化开发面临的问题，</p><ul><li>粒子：算子服务</li><li>AOP领域模型</li><li>面向对象建站</li></ul><h4 id="AOP领域模型"><a href="#AOP领域模型" class="headerlink" title="AOP领域模型"></a>AOP领域模型</h4><ul><li><strong>业务为中心</strong><ul><li><strong>角色升级：从技术执行者到业务设计者</strong><br>  程序员不再局限于编写代码或被动理解需求，而是需要基于对行业的深度认知，主动抽象业务本质，构建高内聚、低耦合的领域模型，驱动技术方案与业务目标对齐。</li><li><strong>模型复用：沉淀行业解决方案</strong><br>  通过提炼共性业务规则与流程，形成可复用的基础领域模型，后续针对不同系统只需在基础模型上扩展差异化逻辑，而非从零开发，提升交付效率与系统一致性。</li></ul></li><li><strong>高内聚、低耦合</strong><ul><li>将同一业务领域的操作逻辑与数据高度聚合，通过标准化接口（如 JSON Schema）暴露能力，降低模块间依赖。</li><li><strong>业务能力封装</strong>：将数据校验、状态流转、业务规则等逻辑内聚在模型中，对外提供声明式接口。</li><li><strong>依赖隔离</strong>：模型内部处理业务逻辑（如库存扣减），外部系统通过 Schema 调用接口，无需感知实现细节。</li></ul></li><li><strong>明确边界</strong><ul><li>按业务语义划分模型边界，避免功能混杂，确保单一模型仅解决特定领域问题。</li><li>例如电商行业的商品管理、订单管理和客户管理是每个电商系统都会用到的，课程管理系统的视频管理、用户管理则可以分别弄成一个基础的模型</li></ul></li><li><strong>领域模型的工程价值</strong><ul><li><strong>降低认知成本</strong>：业务逻辑集中管理，新成员通过模型代码快速理解业务规则。</li><li><strong>提升交付效率</strong>：复用基础模型减少重复开发，例如新建教育系统时直接复用用户模型。</li><li><strong>增强系统弹性</strong>：模型边界清晰，单一业务变更（如修改支付流程）不会波及订单履约模块。</li></ul></li></ul><h4 id="面向对象建站"><a href="#面向对象建站" class="headerlink" title="面向对象建站"></a>面向对象建站</h4><ul><li>创新采用配置驱动开发模式，通过动态渲染引擎实现JSON配置到xxx项目（不同领域有不同的<strong>解析器</strong>）进行自动解析，需求交付周期缩短60%</li></ul><h2 id="二、内核引擎应用开发"><a href="#二、内核引擎应用开发" class="headerlink" title="二、内核引擎应用开发"></a>二、内核引擎应用开发</h2><h3 id="2-1-宏观角度"><a href="#2-1-宏观角度" class="headerlink" title="2.1 宏观角度"></a>2.1 宏观角度</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/4-elpis.png"></p><ul><li><strong>通过约定的规则</strong>，在对应的文件目录放置对应的模块</li><li>通过elpis-core 对文件进行解析挂载到app对象中</li><li>在进行编码时候通过app就可以获取到我们想要使用的能力</li></ul><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/5-elpis.png"></p><h4 id="1-接入层"><a href="#1-接入层" class="headerlink" title="1.接入层"></a>1.接入层</h4><ul><li>接口路由处理，区分API请求，页面请求</li><li>路由规则校验：请求是否满足最基本的校验</li><li>路由中间件：是否携带所需的参数，认证是否通过等</li></ul><h4 id="2-业务层"><a href="#2-业务层" class="headerlink" title="2.业务层"></a>2.业务层</h4><ul><li>controller 处理器</li><li>env 环境区分</li><li>config 全局变量提取</li><li>extend 服务拓展插件</li><li>schedule 定时任务</li></ul><h4 id="3-服务层"><a href="#3-服务层" class="headerlink" title="3.服务层"></a>3.服务层</h4><ul><li>service处理器，是跟数据层的交互</li></ul><h3 id="2-2-解析器"><a href="#2-2-解析器" class="headerlink" title="2.2 解析器"></a>2.2 解析器</h3><p><strong>Elpis的主要功能之一就是实现下面的解析器</strong></p><ul><li>router-loader 解析router请求文件<ul><li>页面请求，</li><li>API请求</li></ul></li><li>router-schema-loader:解析API参数类型校验文件</li><li>middleware-loader: 解析自定义中间件文件</li><li>controller-loader: 解析逻辑处理文件</li><li>service-loader: 解析服务文件（日志，mysql,调用外部服务等）</li><li>extend-loader: 解析扩展文件</li><li>config-loader: 解析配置文件</li></ul><h3 id="2-3-koa洋葱模型"><a href="#2-3-koa洋葱模型" class="headerlink" title="2.3 koa洋葱模型"></a>2.3 koa洋葱模型</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/6-elpis.png"></p><ul><li>业务逻辑前遵从：<strong>先用先处理</strong></li><li>业务逻辑后遵从：<strong>后用先处理</strong></li></ul><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/7-elpis.png"></p><h2 id="三、工程化"><a href="#三、工程化" class="headerlink" title="三、工程化"></a>三、工程化</h2><h3 id="3-1-工程化的核心"><a href="#3-1-工程化的核心" class="headerlink" title="3.1 工程化的核心"></a>3.1 工程化的核心</h3><ul><li>我们编写的代码让浏览器（或者说某个应用）能够识别，工程化就是充当这样的一个中介</li><li>工作提效，一步到位通过一条命令，执行多个配置好的操作，直接打包出产物</li><li>对多种写法进行兼容</li><li>某个框架的盛行，社区的庞大，无形中形成开发的规范</li><li>看完这章节的讲解：用哪个框架不重要，如何处理的思想是在任何一个框架中都想通的，<strong>哪个框架你用起来顺手能解决你的问题都可以</strong> 无需纠结哪个框架，思想最重要</li></ul><h3 id="3-2-流程"><a href="#3-2-流程" class="headerlink" title="3.2 流程"></a>3.2 流程</h3><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/8-elpis.png"></p><p><strong>其中模版解析就是工程化所需要处理的</strong></p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/9-elpis.png"></p><h3 id="3-3-热更新"><a href="#3-3-热更新" class="headerlink" title="3.3 热更新"></a>3.3 热更新</h3><p><strong>热更新一般是在开发时候使用</strong></p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/10-elpis.png"></p><p><strong>原理</strong></p><p>首先通过搭设一台服务器devServer 通过该服务器作为中转站进行通知发送和监控业务文件</p><ul><li>1.监控业务文件变化</li><li>2.业务文件变化后通知打包引擎进行打包，产物放入内存</li><li>3.通知内存文件更新</li><li>4.产物文件进行重新注入</li></ul><p><strong>实现</strong> 本项目是通过express框架实现该功能，而不是使用webpack5自带的devServer配置</p><ul><li>1.使用webpack-dev-middleware作为监听业务文件变化的中间件</li><li>2.webpack-hot-middleware用于通知内存文件更新的信息</li><li>3.webpack.HotModuleReplacementPlugin 用于实现热模块替换(Hot Module Replacement 简称 HMR)基于模块的角度去更新，不会更新整个模块</li></ul><h3 id="3-4-优化"><a href="#3-4-优化" class="headerlink" title="3.4 优化"></a>3.4 优化</h3><p>这项目虽然使用的是webpack5，但是不仅仅局限这个工具，<strong>只要能实现你要的效果都可以</strong></p><p>工程化优化从2个方面思考</p><h4 id="1-构建速度优化"><a href="#1-构建速度优化" class="headerlink" title="1. 构建速度优化"></a>1. 构建速度优化</h4><ul><li>1.devtool:映射源的选择 不同环境使用不同的策略，开发环境可以全面一点，生产环境可以不映射，甚至不让使用者看到source</li><li>2.使用构建缓存 Cache</li><li>3.loader细分需要构建的范围<ul><li>include exclude</li><li>oneOf范围锁定</li></ul></li><li>4.多线程处理loader<ul><li>thread-loader</li><li>happyPack</li></ul></li><li>5.压缩资源的插件尽量使用多线程</li></ul><blockquote><p>问题：使用多线程打包一定是更快吗？</p></blockquote><p>否：首先线程的启动需要时间，若打包很小的模块，反而是负担，时间会更长。 所以一般建议在一些耗时的打包过程开启多线程，另外还可以<strong>通过对比loader plugin开启多线程后的打包时间对比决定了是否开启</strong></p><h4 id="2-首屏渲染加载优化"><a href="#2-首屏渲染加载优化" class="headerlink" title="2.首屏渲染加载优化"></a>2.首屏渲染加载优化</h4><ul><li>1.合理使用浏览器缓存机制：注意打包文件时候contenthash,hash,chunHash的设置</li><li>2.静态资源的压缩（建议在打包到生产才开启）<ul><li>js：terser</li><li>css:css-minimizer-webpack-plugin</li><li>image:image-minimizer-webpack-plugin等插件只是辅助作用</li></ul></li></ul><blockquote><p>图片压缩一定在webpack打包完成吗？</p></blockquote><p>个人觉得image-minimizer-webpack-plugin这些压缩挺费时间，静态资源图片若可以，我建议使用tinypng压缩即可，之前我工作中ui已经帮我压缩的很极致。</p><ul><li>3.tree-shaking（树摇）运用</li><li>4.分包：目的使用浏览器可以并行下载的优势，vue中路由的懒加载也是这个原理<ul><li>第三方库为一个包</li><li>业务代码为一个包</li><li>公用方法一个包</li></ul></li></ul><blockquote><p>这里注意若elementui使用的是按需加载，这时候建议单独分为一个包，因为会因为你加载的组件前后不一，第三方库的包contenthash会改变，会导致缓存失效</p></blockquote><blockquote><p>包分的越多越好？首先服务器不支持http2.0的情况不支持多路复用，浏览器（谷歌）只能同时并发同域名的6个请求，而且启动请求还需要tcp握手等操作，所以包并不是越多越好，还需要考虑包的大小</p></blockquote><ul><li>5.项目中合理使用preload和 prefetch加载资源</li></ul><h2 id="四、Dashboard模版"><a href="#四、Dashboard模版" class="headerlink" title="四、Dashboard模版"></a>四、Dashboard模版</h2><p>当前开发一个系统（以中后台系统为例子），大部分程序员都是产品说出一个页面的需求，程序员看到什么就开始开发什么，这样会导致大量的重复CRUD的工作，对自身的成长没有什么帮助 有点经验的，就会根据自身的开发习惯，对页面部分对页面进行封装，通过配置的方式渲染页面，虽然更灵活了减少了一定的工作量，但这种往往难以形成统一的风格，往往需要根据需求进行妥协，在开发到一定时间后，组件反而会很冗余不好维护</p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/11-elpis.png"></p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/12-elpis.png"> </p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/13-elpis.png"></p><h3 id="4-1-在接触elpis前，自己设计的大屏系统也有类似的想法，以下是大致的描述"><a href="#4-1-在接触elpis前，自己设计的大屏系统也有类似的想法，以下是大致的描述" class="headerlink" title="4.1 在接触elpis前，自己设计的大屏系统也有类似的想法，以下是大致的描述"></a>4.1 在接触elpis前，自己设计的大屏系统也有类似的想法，以下是大致的描述</h3><p>通过布局组件（layout-comp）将页面分为24*24的区域，利用动态组件+插槽的方式保证系统的灵活性</p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/14-elpis.png"></p><p>通过配置的方式对区域大小进行渲染</p><ul><li>左1描述</li></ul><pre class="line-numbers language-js"><code class="language-js">chartsData<span class="token punctuation">:</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 左1</span>    grid<span class="token punctuation">:</span> <span class="token punctuation">{</span>      x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>      y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移0 个单元格</span>      w<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占12个单元格</span>      h<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的12个单元格</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    key<span class="token punctuation">:</span><span class="token string">'0'</span><span class="token punctuation">,</span>    linkKey<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>    bcType<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// border边框类型, image背景图, null 不做操作</span>    bc<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 对应bcType类型</span>    children<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 内嵌块，布局组件也将内部块分为24*24个格子，</span>    <span class="token comment" spellcheck="true">// 将其封装在一个数组中，最后再进行渲染</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>右1描述</li></ul><pre class="line-numbers language-js"><code class="language-js">chartsData<span class="token punctuation">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 右1</span>    grid<span class="token punctuation">:</span> <span class="token punctuation">{</span>      x<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>      y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移0 个单元格</span>      w<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占12个单元格</span>      h<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的12个单元格</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    key<span class="token punctuation">:</span><span class="token string">'1'</span><span class="token punctuation">,</span>    bcType<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// border边框类型, image背景图, null 不做操作</span>    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定位于 右1描述方框</span>        grid<span class="token punctuation">:</span><span class="token punctuation">{</span>          x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>          y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移0 个单元格</span>          w<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占24个单元格</span>          h<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的12个单元格</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        key<span class="token punctuation">:</span><span class="token string">'1-1'</span><span class="token punctuation">,</span>        linkKey<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>        compType<span class="token punctuation">:</span><span class="token string">'柱状图'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>        data<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数据放在这参数上。这里省略只是描述出来有这个字段</span>        compStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>          color<span class="token punctuation">:</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span>          fontSize<span class="token punctuation">:</span><span class="token string">'xxxx'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定位于 右1描述方框</span>        grid<span class="token punctuation">:</span><span class="token punctuation">{</span>          x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>          y<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移12 个单元格</span>          w<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占24个单元格</span>          h<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的12个单元格</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        key<span class="token punctuation">:</span><span class="token string">'1-2'</span><span class="token punctuation">,</span>        linkKey<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>        compType<span class="token punctuation">:</span><span class="token string">'饼图组件'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码用来定义需要渲染的组件</span>        data<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数据放在这参数上。这里省略只是描述出来有这个字段</span>        compStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>          color<span class="token punctuation">:</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span>          fontSize<span class="token punctuation">:</span><span class="token string">'xxxx'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>右下一描述</li></ul><pre class="line-numbers language-js"><code class="language-js">chartsData<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 右下1</span>    grid<span class="token punctuation">:</span> <span class="token punctuation">{</span>      x<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>      y<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移0 个单元格</span>      w<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占12个单元格</span>      h<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的12个单元格</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    key<span class="token punctuation">:</span><span class="token string">'3'</span><span class="token punctuation">,</span>    linkKey<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>    bcType<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// border边框类型, image背景图, null 不做操作</span>    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定位于 右下1描述方框</span>        grid<span class="token punctuation">:</span><span class="token punctuation">{</span>          x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>          y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移0 个单元格</span>          w<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占24个单元格</span>          h<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的6个单元格</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        key<span class="token punctuation">:</span><span class="token string">'3-0'</span><span class="token punctuation">,</span>        linkKey<span class="token punctuation">:</span><span class="token string">'3-1'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>        compType<span class="token punctuation">:</span><span class="token string">'统计文字'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>        data<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数据这里省略只是描述出来有这个字段</span>        compStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>          color<span class="token punctuation">:</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span>          fontSize<span class="token punctuation">:</span><span class="token string">'xxxx'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定位于 右下1描述方框</span>        grid<span class="token punctuation">:</span><span class="token punctuation">{</span>          x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 向左偏移0 个单元格</span>          y<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 向上偏移6 个单元格</span>          w<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 宽度占24个单元格</span>          h<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 高度占纵向的18个单元格</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        key<span class="token punctuation">:</span><span class="token string">'3-1'</span><span class="token punctuation">,</span>        linkKey<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 关联的key,用于实现数据联动操作影响到哪个组件</span>        compType<span class="token punctuation">:</span><span class="token string">'关联列表'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>        data<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数据这里省略只是描述出来有这个字段</span>        compStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>          color<span class="token punctuation">:</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span>          fontSize<span class="token punctuation">:</span><span class="token string">'xxxx'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 伪代码</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span>  <span class="token operator">...</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h4><h5 id="1-需求对齐与设计规范固化"><a href="#1-需求对齐与设计规范固化" class="headerlink" title="1. 需求对齐与设计规范固化"></a>1. <strong>需求对齐与设计规范固化</strong></h5><ul><li><strong>问题</strong>：研发初期仅与UI单点对齐，缺乏产品侧对系统能力的全局输入，导致不同产品设计大屏时交互逻辑碎片化，DSL被迫承载过多兼容逻辑，维护成本攀升。</li><li><strong>优化方案</strong>：<ul><li><strong>三方协作机制</strong>：建立产品-研发-UI的定期需求同步会，明确系统当前支持的交互范式与技术边界。</li><li><strong>DSL分层设计</strong>：<ul><li><strong>核心层</strong>：固化通用交互标准（如数据筛选、图表联动），尽可能减少业务定制。</li><li><strong>扩展层</strong>：通过插件机制支持低频定制需求，避免污染核心逻辑。</li></ul></li><li><strong>设计系统落地</strong>：将高频交互场景沉淀为可视化配置项，产品直接基于标准模板设计，减少技术兜底。</li></ul></li></ul><h5 id="2-数据接口协作模式升级"><a href="#2-数据接口协作模式升级" class="headerlink" title="2. 数据接口协作模式升级"></a><strong>2. 数据接口协作模式升级</strong></h5><ul><li><strong>问题</strong>：依赖文档传递数据规范，后端需反复理解适配，协作效率低下。</li><li><strong>优化方案</strong>：<ul><li><strong>BFF层抽象</strong>：在前端与后端间增加BFF（Backend for Frontend）层，实现以下能力：<ul><li><strong>接口聚合</strong>：将多个微服务接口合并为前端友好格式。</li><li><strong>数据转换</strong>：统一驼峰/下划线命名、枚举值映射等差异。</li><li><strong>Mock机制</strong>：基于契约自动生成模拟数据，前端不阻塞开发。</li></ul></li><li><strong>协作分工</strong>：<ul><li>后端：仅保障原始数据准确性（如SQL执行效率、事务一致性）。</li><li>BFF层：由前端主导开发，负责业务数据适配。</li></ul></li></ul></li></ul><h5 id="3-组件分层架构优化"><a href="#3-组件分层架构优化" class="headerlink" title="3. 组件分层架构优化"></a><strong>3. 组件分层架构优化</strong></h5><ul><li><strong>问题</strong>：业务逻辑侵入基础组件（如弹窗包含审批流），导致复用性与维护性下降。</li><li><strong>优化方案</strong>：<ul><li><strong>三层架构设计</strong>：<table><thead><tr><th><strong>层级</strong></th><th><strong>职责</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>基础组件层</strong></td><td>纯UI渲染，无业务逻辑</td><td><code>&lt;Modal&gt;</code> 仅处理显示/隐藏动画</td></tr><tr><td><strong>业务桥接层</strong></td><td>处理数据转换、事件分发</td><td><code>ApprovalModalAdapter</code> 对接审批接口</td></tr><tr><td><strong>场景封装层</strong></td><td>组合多组件实现完整业务流</td><td><code>LeaveApprovalFlow</code> 包含表单、弹窗、状态机</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li><li><strong>事件驱动通信</strong>：组件通过自定义事件（如 <code>@submit</code>）与桥接层交互，彻底解耦逻辑与视图。</li></ul></li><li>样式定义（compStyle）为了灵活，图表的参数遵从了echarts官网的参数,这导致了学习成本提高，因为在使用过程中发现，每个系统所需要的图表风格较为相似应该 做多一个样式解析器即可，降低配置人员的学习成本</li></ul><h5 id="4-可视化配置体验优化"><a href="#4-可视化配置体验优化" class="headerlink" title="4. 可视化配置体验优化"></a><strong>4. 可视化配置体验优化</strong></h5><ul><li><strong>问题</strong>：直接暴露ECharts复杂参数，配置门槛高且重复劳动。</li><li><strong>优化方案</strong>：<ul><li><strong>配置分层策略</strong>：<ul><li><strong>基础样式包</strong>：封装通用主题（颜色、字体、间距），通过 <code>compStyle</code> 一键应用。</li><li><strong>语义化配置器</strong>：将ECharts参数转换为业务术语（如「指标轴」替代 <code>yAxis.name</code>）</li><li><strong>模板中心</strong>：沉淀各系统高频图表配置（如「销售漏斗」「用户留存曲线」），支持克隆后微调。</li></ul></li></ul></li></ul><h3 id="4-2-DSL"><a href="#4-2-DSL" class="headerlink" title="4.2 DSL"></a>4.2 DSL</h3><p>DSL是一种专门为某个特定领域或问题域设计的编程语言。它的主要目的是提供一种简洁、易于使用和高效的方式来描述和解决特定领域的问题。本框架通过dsl -&gt;解析器-&gt;模版页面</p><p>大致框架如下：<strong>其中绿色为自定义组件</strong>：可自行变动保证灵活性，<strong>蓝色部分为已设计部分</strong>：固定部分减少重复操作</p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/15-elpis.png"></p><h4 id="1-elpis核心：80-配置减少重复工作，-20-定制化增加系统的拓展性"><a href="#1-elpis核心：80-配置减少重复工作，-20-定制化增加系统的拓展性" class="headerlink" title="1. elpis核心：80%配置减少重复工作， 20%定制化增加系统的拓展性"></a>1. elpis核心：80%配置减少重复工作， 20%定制化增加系统的拓展性</h4><p>通过<strong>json-schema</strong>的定义规范对字段进行描述</p><p>上面是对管理后台系统为背景进行的DSL设计</p><h5 id="1-1菜单栏参数设计"><a href="#1-1菜单栏参数设计" class="headerlink" title="1.1菜单栏参数设计"></a>1.1菜单栏参数设计</h5><pre class="line-numbers language-js"><code class="language-js">menu<span class="token punctuation">:</span><span class="token punctuation">[</span>  <span class="token punctuation">{</span>     key<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 每个菜单的key</span>     name<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>     menuType<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// module group 根据不同的值用到下面不同的数据</span>     subMenu<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 可递归的menuItem</span>     moduleType<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 当menuType 为module时， 枚举值: sider / iframe / custom / schema</span>     siderConfig<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 对应 sider</span>     iframeConfig<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 对应iframe</span>     customConfig<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 对应custom</span>     schemaConfig<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 对应schema的时候</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2页面布局组件"><a href="#1-2页面布局组件" class="headerlink" title="1.2页面布局组件"></a>1.2页面布局组件</h5><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/16-elpis.png"></p><ul><li>header-view用来处理菜单栏的点击逻辑，并根据所点击的键去发送事件出上层组件影响 slot:main-content渲染内容</li><li>header-container 一个纯进行渲染的组件不进行逻辑处理</li><li>slot:menu-content 根据 menu[…]进行菜单的渲染</li><li>slot:setting-content 保留给用户自定义的站位</li><li>slot:main-content : 根据moduleType的不同 main-content 会定向到不同的页面，其中<strong>schema类型将是重点</strong></li></ul><h4 id="iframe-view"><a href="#iframe-view" class="headerlink" title="iframe-view"></a>iframe-view</h4><p>当 moduleType为 iframe 读取iframeConfg.path iframe进行渲染</p><h4 id="custom-view"><a href="#custom-view" class="headerlink" title="custom-view"></a>custom-view</h4><p>当 moduleType为 custom 读取customConfg.path 路由进行csr (用于定制页面)</p><h4 id="schema-view：重点"><a href="#schema-view：重点" class="headerlink" title="schema-view：重点"></a>schema-view：重点</h4><p>当 moduleType为 schema时，我们就需要对schemaConfig参数进行解析</p><ul><li>api<ul><li>该页面涉及到的api,遵从Restful规范</li></ul></li><li>schema<ul><li>数据源参数的描述，可以理解为api返回的数据字段，我怎么展示</li></ul></li><li>tableConfig<ul><li>表单配置，头部按钮组件返回什么事件，row按钮会触发的事件等</li></ul></li><li>searchConfig<ul><li>search-bar 板块相关配置</li></ul></li><li>components<ul><li>页面涉及到的子组件</li></ul></li></ul><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/17-elpis.png"></p><p>大致可以理解为这样一张图，核心就是我需要哪个模块，我就新增一个配置用来描述，通过解析器解析成对应的模块</p><p>我需要什么就新增一个描述，<strong>通过解析器转换成渲染组件所需要的数据，然后进行渲染交互</strong></p><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/18-elpis.png"></p><h2 id="五-动态组件"><a href="#五-动态组件" class="headerlink" title="五.动态组件"></a>五.动态组件</h2><h3 id="5-1设计组件的考虑"><a href="#5-1设计组件的考虑" class="headerlink" title="5.1设计组件的考虑"></a>5.1设计组件的考虑</h3><ul><li>考虑组件需要什么参数<ul><li>首先先要从组件功能进行考虑先进行一个大概的梳理</li><li>禁止那种需要什么参数再进行补充的思路</li></ul></li><li>考虑需要暴露什么事件<ul><li>考虑组件功能，会给外部带来怎么的联动功能</li></ul></li><li>考虑暴露什么属性<ul><li>需要考虑在使用过程中需要用到内部的什么属性？切记返回对应的方法，禁止直接修改属性</li></ul></li><li>考虑slot可拓展的东西<ul><li>这里就需要考虑什么部分是可以沉淀的通用配置，剩下的部分是灵活配置</li></ul></li></ul><h3 id="5-2设计结构"><a href="#5-2设计结构" class="headerlink" title="5.2设计结构"></a>5.2设计结构</h3><pre class="line-numbers language-Javascript"><code class="language-Javascript">{  model: "xxx", //模版类型  name: "", // 模版名称  desc: "", // 模版描述  icon: "", // 模版图标  homePage: "", // 首页(项目配置)  // 头部菜单 只展示moduleType:'schema'时候组件对应的参数  menu: [    {      menuType: "module", // 菜单类型 枚举值 group / module      moduleType: "schema", // 当 menuType 为 module 时,可填      schemaConfig: {        api: "xxxx",        schema: {          type: "object",          properties: {            // 对应的一个字段            key: {              // !!!! 这里是重点 命名规则： xxxOption              // xxx:对应每个组件的名字              // 字段在不同动态 component中的相关配置，前缀对应 componentConfig中的键值              // 如：componentConfig.createForm,这里对应 createFormOption              // 字段在createForm中的相关配置              createFormOption: {                ...eleComponentConfig, // 标准 el-component 配置                comType: "", //控件类型 配置组件类型 input/select/....                visible: true, // 是否显示 默认为 true 显示 （false ，表示不在表单中显示）                disabled: false, // 是否禁用(true/false)  默认为 false                default: "", // 默认值                // compType === 'select' 时生效                enumList: [], // 选项列表              },            },            ...          },        },        // 动态组件 相关配置,        // 任何页面用到的动态组件都需要在这里配置        componentConfig: {          // 新增 create-form 表单相关配置          createForm: {            title: "表达配置", // 表单标题            saveBtnText: "保存", // 保存按钮文本          },          // edit-form 表单相关配置          editForm: {            mainKey: "", // 表单主键,用于唯一标识要修改的数据对象            title: "", // 表单标题            saveBtnText: "", // 保存按钮文本          },          // detail-panel 相关配置          detailPanel: {            mainKey: "", // 表单主键,用于唯一标识要修改的数据对象            title: "", // 表单标题          },          // 支持动态配置        },      },    },  ],};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3组件结构管理"><a href="#5-3组件结构管理" class="headerlink" title="5.3组件结构管理"></a>5.3组件结构管理</h3><pre class="line-numbers language-css"><code class="language-css"> app                                                                                     │  │  ├─ pages                                                                        │  │  │  ├─ dashboard                                               │  │  │  │  ├─ complex-view                                                             │  │  │  │  │  ├─ schema-view                                       │  │  │  │  │  │  ├─ complex-view                                   │  │  │  │  │  │  │  ├─ components                                  │  │  │  │  │  │  │  │  ├─ create-form                              │  │  │  │  │  │  │  │  │  └─ create-form<span class="token number">.</span>vue                       │  │  │  │  │  │  │  │  ├─ detail-panel                             │  │  │  │  │  │  │  │  │  └─ detail-panel<span class="token number">.</span>vue                      │  │  │  │  │  │  │  │  ├─ edit-form                                │  │  │  │  │  │  │  │  │  └─ edit<span class="token number">.</span>form<span class="token number">.</span>vue                         │  │  │  │  │  │  │  │  └─ component-config<span class="token number">.</span>ts    │  │  │  ├─ widgets                                                                    │  │  │  │  ├─ schema-form                                          │  │  │  │  │  ├─ complex-view                                      │  │  │  │  │  │  ├─ input                                          │  │  │  │  │  │  │  └─ input<span class="token number">.</span>vue                                   │  │  │  │  │  │  ├─ input-number                                   │  │  │  │  │  │  │  └─ input-number<span class="token number">.</span>vue                            │  │  │  │  │  │  └─ select                                         │  │  │  │  │  │     └─ select<span class="token number">.</span>vue                                  │  │  │  │  │  ├─ form-item-config<span class="token number">.</span>ts                               │  │  │  │  │  └─ schema-form<span class="token number">.</span>vue      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4为什么不用element-ui的表单校验功能"><a href="#5-4为什么不用element-ui的表单校验功能" class="headerlink" title="5.4为什么不用element-ui的表单校验功能"></a>5.4为什么不用element-ui的表单校验功能</h3><ul><li>因为我们使用Json-schema的标准，Json-schema已经有很完善的验证机制（更好的做到数据驱动视图）</li><li>只需要结合ajv插件即可判断组件内部的数据是否符合我们的要求</li><li>另一层面可以统一团队的代码校验统一性，减少不必要的学习成本</li></ul><h2 id="六-npm封装打包"><a href="#六-npm封装打包" class="headerlink" title="六.npm封装打包"></a>六.npm封装打包</h2><h3 id="6-1npm封装打包目的"><a href="#6-1npm封装打包目的" class="headerlink" title="6.1npm封装打包目的"></a>6.1npm封装打包目的</h3><ul><li>将一些重复性代码与业务需求的代码进行分离</li><li>利于项目的管理，只让elpis维护的成员能对沉淀的代码进行修改，使用者只需关心自身20%的业务逻辑</li></ul><h3 id="6-2npm封装，elpis需要考虑哪些方面"><a href="#6-2npm封装，elpis需要考虑哪些方面" class="headerlink" title="6.2npm封装，elpis需要考虑哪些方面"></a>6.2npm封装，elpis需要考虑哪些方面</h3><h4 id="6-2-1-node端"><a href="#6-2-1-node端" class="headerlink" title="6.2.1 node端"></a>6.2.1 node端</h4><ul><li>对外部文件的兼容 （支持业务controller、extend、router、router-schema、全局中间件、config配置）的拓展</li><li>elpis-core内部路径指向修改，业务文件指向问题 （）， __dirname 和 process.cwd()区分</li></ul><h4 id="6-2-2-webpack端"><a href="#6-2-2-webpack端" class="headerlink" title="6.2.2 webpack端"></a>6.2.2 webpack端</h4><ul><li><p>对之前的构建函数进行抽离暴露，业务端根据环境变量进行判断方法调用</p></li><li><p>elpis的entry页面 和业务的entry页面抽离</p></li><li><p>elpis方法和组件进行暴露</p></li><li><p>babel-loader等插件使用require.resolve(‘xxx’)进行引入</p></li><li><p>暴露自定义页面(外部定义路由，暴露方法)到entry.dashboard进行合并</p></li><li><p>暴露组件</p><pre class="line-numbers language-js"><code class="language-js">   <span class="token comment" spellcheck="true">// 业务拓展 component 配置</span>   <span class="token keyword">import</span> BusinessComponentConfig <span class="token keyword">from</span> <span class="token string">'$businessComponentConfig'</span>   <span class="token keyword">const</span> ComponentConfig<span class="token punctuation">:</span>componentConfigType <span class="token operator">=</span> <span class="token punctuation">{</span>     createForm<span class="token punctuation">:</span><span class="token punctuation">{</span>       component<span class="token punctuation">:</span>createForm<span class="token punctuation">,</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span>     editForm<span class="token punctuation">:</span><span class="token punctuation">{</span>       component<span class="token punctuation">:</span>editForm<span class="token punctuation">,</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span>     detailPanel<span class="token punctuation">:</span><span class="token punctuation">{</span>       component<span class="token punctuation">:</span>detailPanel     <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>     <span class="token operator">...</span>ComponentConfig<span class="token punctuation">,</span>     <span class="token operator">...</span>BusinessComponentConfig   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-3npm发布流程"><a href="#6-3npm发布流程" class="headerlink" title="6.3npm发布流程"></a>6.3npm发布流程</h3><ul><li>注册一个npm账号</li><li>Elpis 项目名称带上账号名称 @xxxx/elpis</li><li>本地调试<ul><li>Elpis项目中执行npm link</li><li>Elpis-demo 项目 npm link @xxxx/elpis</li></ul></li><li>调试完后 npm config get registry查看npm链接到哪个源</li><li>npm config set registry <strong>恢复默认源</strong></li><li>npm login <strong>登录npm</strong></li><li>npm whoami <strong>查看当前用户名</strong></li><li>npm publish ****<strong>--access public 首次发布需要加上后面这个后缀</strong></li></ul><h3 id="6-4达成elpis核心思想沉淀80-20-灵活配置"><a href="#6-4达成elpis核心思想沉淀80-20-灵活配置" class="headerlink" title="6.4达成elpis核心思想沉淀80% 20%灵活配置"></a>6.4达成elpis核心思想沉淀80% 20%灵活配置</h3><ul><li>1.通过npm打包将重复性的操作进行80%沉淀（每个公司都有自己的规则）业务性</li><li>2.每个项目通过引用 elpis包，然后自身的业务项目代码就通过elpis规则进行定义即可</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实践 </tag>
            
            <tag> node </tag>
            
            <tag> koa </tag>
            
            <tag> vue3 </tag>
            
            <tag> webpack5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABT在前端基建中的实践</title>
      <link href="/2024/06/24/abt-zai-qian-duan-ji-jian-zhong-de-shi-jian/"/>
      <url>/2024/06/24/abt-zai-qian-duan-ji-jian-zhong-de-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="ABT在前端基建中的实践"><a href="#ABT在前端基建中的实践" class="headerlink" title="ABT在前端基建中的实践"></a>ABT在前端基建中的实践</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>产品有时无法确定哪种设计方案更好，因此希望前端能够同时上线多个产品方案，根据某套规则将用户导流到不同的方案。</p><img src="https://resource.duyiedu.com/yuanjin/202403051146503.png" alt="image-20240305114633270" style="zoom: 30%;"><p>在用户体验理论研究中，这种做法称之为A/B Testing（后续简称ABT）。</p><p>一次ABT实验会生成至少两套方案（对照组/实验组），并且可以允许多个实验共存。</p><p>ABT实验会涉及多个岗位的协调，包含：前端、后端、测试、运维、产品，其中起主要作用的是产品和前端。</p><h2 id="问题和方案"><a href="#问题和方案" class="headerlink" title="问题和方案"></a>问题和方案</h2><p>ABT为前端带来诸多的挑战，其中包括：</p><h3 id="如何协作？"><a href="#如何协作？" class="headerlink" title="如何协作？"></a>如何协作？</h3><p>在一个实验生命周期内涉及到哪些角色，角色之间是如何协作的？</p><p><img src="https://resource.duyiedu.com/yuanjin/202403051356686.png" alt="image-20240305135601652"></p><h3 id="前端如何开发？"><a href="#前端如何开发？" class="headerlink" title="前端如何开发？"></a>前端如何开发？</h3><p>实验具有以下几个特点：</p><ol><li>多个实验共存<br>产品可能会先后发起几十个甚至上百个实验，不同的实验有不同的分流规则，每个实验又有多个对照组</li><li>实验是精确到组件的，一个实验对应到多个前端组件<br>一个组件不同的对照组之间的差异是灵活的</li><li>实验是频繁的</li><li>用户参与实验必须是无感的</li><li>实验推全后只保留一个对照组</li></ol><h4 id="流程和结构"><a href="#流程和结构" class="headerlink" title="流程和结构"></a>流程和结构</h4><p>ABT运作流程</p><p><img src="https://resource.duyiedu.com/yuanjin/202403051518808.png" alt="image-20240305151808775"></p><p>ABT SDK的结构</p><p><img src="https://resource.duyiedu.com/yuanjin/202403061918012.png" alt="image-20240306191832940"></p><p>整个ABT-SDK包含了诸多API和工具，为应用开发提供支撑，其中</p><ul><li>ABTCore： 提供ABT最底层的核心功能，比如实验信息、分流控制、代码剪枝、数据决策等等</li><li>ABT-Server： 针对服务器提供一些中间件</li><li>ABT-Vue/ABT-React： 针对前端两种框架提供一些组件、仓库、路由等</li><li>ABT-Webpack/ABT-Vite： 针对前端两种常见构建工具，提供一些插件集成，比如ESLint工具、PostCSS插件、命令行工具等等</li></ul><h4 id="如何分流？"><a href="#如何分流？" class="headerlink" title="如何分流？"></a>如何分流？</h4><ol><li>使用Redis存储当前每个实验不同对照组的参与人数</li><li>使用浏览器指纹+用户身份保证同一用户对同一实验仅参与一个组<br>两种做法<ul><li>将指纹+用户身份+组打包成JWT发送给客户端（不精准，成本低）</li><li>使用数据库保存映射关系（精准，成本高）</li></ul></li><li>按照规则中的分流比例为新用户分配组别</li><li>将所有实验的ID，以及每个组别的编号下发到客户端</li></ol><h4 id="如何改变运行代码？"><a href="#如何改变运行代码？" class="headerlink" title="如何改变运行代码？"></a>如何改变运行代码？</h4><p>实验和组别对运行时的影响主要是渲染组件的不同，但也有可能对其他代码造成影响。</p><p>由于每次实验所产生的差异是极其灵活的，因此难以使用一种标准化的静态格式来描述差异，这就不可避免的造成了对业务代码的侵入。</p><p>基建的一个重要目标就是要将这种侵入最小化、标准化。</p><p><strong>提供高阶组件屏蔽组件差异</strong></p><p>vue示例</p><pre class="line-numbers language-vue"><code class="language-vue"><ABTesting name="exp1">    <template #default>        <DefaultComp></DefaultComp>  </template>  <template #groupB>      <GroupBComp></GroupBComp>  </template>  <template #groupC>       <GroupCComp></GroupCComp>  </template></ABTesting><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>react示例</p><pre class="line-numbers language-react"><code class="language-react"><ABTesting   name="exp1"  groupB={<GroupBComp></GroupBComp>}  groupC={<GroupCComp></GroupCComp>}  >    <DefaultComp></DefaultComp></ABTesting><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提供高阶函数屏蔽API差异</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> utilMethod <span class="token operator">=</span> ABTCore<span class="token punctuation">.</span><span class="token function">choose</span><span class="token punctuation">(</span><span class="token string">'exp1'</span><span class="token punctuation">,</span> defaultMethod<span class="token punctuation">,</span> groupBMethod<span class="token punctuation">,</span> groupCMethod<span class="token punctuation">)</span><span class="token keyword">const</span> result <span class="token operator">=</span> ABTCore<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exp1'</span><span class="token punctuation">,</span> defaultMethod<span class="token punctuation">,</span> groupBMethod<span class="token punctuation">,</span> groupCMethod<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>使用自定义指令屏蔽CSS差异</strong></p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* style.css */</span><span class="token atrule"><span class="token rule">@ab-testing</span> exp1</span> <span class="token punctuation">{</span>  <span class="token selector">default </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* default styles */</span>    <span class="token selector"><span class="token class">.a</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token selector">groupB </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* groupB styles */</span>    <span class="token selector"><span class="token class">.a</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用自定义的PostCSS插件，会将上面的代码转换为</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">exp1-default-a</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token selector">exp1-groupb-a</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>与此同时，我们也改变了CSS Modules。</p><p>默认情况下，开启CSS Modules后，上面的代码会被转换为下面的JS</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token string">"exp1-default-a"</span><span class="token punctuation">:</span> <span class="token string">"hash1"</span><span class="token punctuation">,</span>  <span class="token string">"exp1-groupB-a"</span><span class="token punctuation">:</span><span class="token string">"hash2"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们对此作了改变，将代码变成了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> chooseValue <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"ABTCore"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">chooseValue</span><span class="token punctuation">(</span><span class="token string">"exp1"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      a<span class="token punctuation">:</span> <span class="token string">"hash1"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    groupB<span class="token punctuation">:</span> <span class="token punctuation">{</span>      a<span class="token punctuation">:</span> <span class="token string">"hash2"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实验推全后如何处理？"><a href="#实验推全后如何处理？" class="headerlink" title="实验推全后如何处理？"></a>实验推全后如何处理？</h4><p>当产品完成实验后，会选定一种方案进行推全。</p><p>此时，会涉及到对应实验的代码如何剪枝的问题？</p><p>由于实验SDK并不向外界暴露当前用户所处的实验分组，因此，业务开发者要根据不同分组进行不同处理的代码逻辑必须使用实验SDK才能完成。</p><p>这就对自动化的实验推全提供了基础，由于所有的实验代码都是使用SDK完成的，因此可以通过一个简洁的逻辑即可完成自动化实验推全：</p><ol><li>实验SDK为各种构建工具提供插件</li><li>打包时，插件会通过代码分析（AST），找出当前哪些文件对应到哪些实验</li><li>插件会对照最新的实验信息，找到已经被推全的实验</li><li>插件定位到所有与该实验有关的源码文件</li><li>插件提示开发者，是否对已推全的实验进行剪枝</li><li>开发者确认后，插件自动修改AST完成剪枝</li></ol><p>通过AST完成剪枝逻辑是非常容易的</p><p>比如针对组件的剪枝</p><p>剪枝前</p><pre class="line-numbers language-vue"><code class="language-vue"><ABTesting name="exp1">    <template #default>        <DefaultComp></DefaultComp>  </template>  <template #groupB>      <GroupBComp></GroupBComp>  </template>  <template #groupC>       <GroupCComp></GroupCComp>  </template></ABTesting><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>剪枝后（假设将groupB推全）</p><pre class="line-numbers language-vue"><code class="language-vue"><GroupBComp></GroupBComp><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="细节问题？"><a href="#细节问题？" class="headerlink" title="细节问题？"></a>细节问题？</h4><p><strong>白屏问题</strong></p><p>对于一个CSR应用，它的组件渲染取决于所处的组别，而它所属哪个组别又必须通过网络通信才能确定。</p><p>这就导致了首屏渲染的白屏问题。</p><img src="https://resource.duyiedu.com/yuanjin/202403061936643.png" alt="image-20240306193644580" style="zoom:33%;"><p>而我们观察到整个应用中实际上只有部分组件会参与到实验，对于没有参与到实验的组件是不需要等待分组信息的。</p><p>因此，我们将参与到实验的组件制作为异步组件，从而可以不影响其他组件的渲染。</p><p><img src="https://resource.duyiedu.com/yuanjin/202403061940236.png" alt="image-20240306194033162"></p><p><strong>代码检查问题</strong></p><p>由于实验推全时需要对代码进行剪枝，剪枝发生在编译时态，它通过AST检查代码中包含的ABT-SDK代码完成，而大部分ABT-SDK中的API都需要绑定实验名称，例如：</p><pre class="line-numbers language-js"><code class="language-js">ABTCore<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'exp1'</span><span class="token punctuation">,</span> defaultMethod<span class="token punctuation">,</span> groupBMethod<span class="token punctuation">,</span> groupCMethod<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果实验名称来自于一个变量或表达式或者其他需要在运行时才能确定的值，这就会导致剪枝失败。</p><p>因此我们制作了ESLint插件来约束开发者必须使用字面量或者其他在编译时态能确定的值。</p><p><strong>开发规范</strong></p><p>ABT-SDK不会暴露用户的分组信息给开发者，这主要是考虑到开发者可能写出下面的代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>用户的分组 <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 代码1</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>用户的分组 <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 代码2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的代码无法被代码剪枝工具察觉，容易在实验推全后仍然保留在代码中，虽然功能性不受影响，但会逐步降低代码的可维护性。</p><p>以上是不暴露的主要原因。</p><p>但开发者仍然有可能间接的获取到用户的分组，比如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> ABTCore<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"exp1"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  groupB<span class="token punctuation">:</span> <span class="token string">"B"</span><span class="token punctuation">,</span>  groupC<span class="token punctuation">:</span> <span class="token string">"C"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">===</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 代码1</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">===</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 代码2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种代码很难通过自动化工具检查处理，因此需要通过开发规范来约束：</p><p><em>所有跟实验相关的处理，必须通过ABT-SDK完成</em></p><h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p><strong>项目名</strong>： XXX项目前端ABT-SDK基建 </p><p><strong>岗位</strong>： 高级前端工程师 / 前端架构师</p><p><strong>项目介绍</strong>： </p><ol><li>ABT-SDK是一套为AB实验提供技术支撑的开发工具包，它分为底层的ABT-Core，以及上层的ABT-Server、ABT-Vue、ABT-React、ABT-Webpack、ABT-Vite，可以集成到BFF、Vue/React框架、Webpack/Vite工程。</li><li>整个ABT-SDK的开发使用到了诸多前端技术，包括但不仅限于： 自定义PostCSS/ESLint/Webpack/Vite插件、AST分析、浏览器指纹、Vue/React高阶组件、脚手架开发…</li></ol><p><strong>项目职责</strong>：</p><ol><li>参与ABT工具链的开发和集成</li><li>参与ABT规范和协作流程的制定</li><li>参与ABT和前端框架的集成</li><li>其他技术难点攻坚</li></ol><p><strong>项目亮点</strong>：</p><p>从0到1开发整个A/B Testing SDK，为产品制定AB实验提供技术支撑，SDK可作用于Vue、React、Webpack、Vite、BFF等前端常见的技术场景，为AB实验开发提供全流程支撑。</p><p>整套SDK不仅中止了AB实验业务开发的混乱局面，为前端AB实验业务的开发提效70%，减少90%的代码出错几率，同时大幅提升代码质量。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p><strong>请介绍你开发的A/B Testing SDK</strong></p><blockquote><p>先讲背景</p></blockquote><p>这套SDK是为支撑AB实验研发的，属于是我们前端基建的一部分。</p><!--AB实验是用户体验研究的一套方法论-->。<!--在设计产品时，产品设计师有时可能希望同时上架种设计方案，然后观察每种方案得到的数据反馈，业内把这种做法就叫做AB实验，意思是通过AB两个组别来获取数据支撑，在实际的场景中，可能会有更多的组别。--><p>之所以要开发这套SDK，是因为在没有它之前，要走完一次AB实验的流程成本是非常高的，<strong>后来经过我的调研和分析</strong>，造成这种高成本的根本原因就是缺乏标准化。</p><p>具体来说体现在几个方面：</p><ol><li>没有标准化的流程 –&gt; 管理成本<br>举例： 实验冲突问题</li><li>没有标准化的工具 –&gt; 维护成本<br>举例： 实验推全时代码剪枝问题</li><li>没有标准化的API –&gt; 开发成本<br>举例： AB实验全面侵入业务代码，心智负担过重</li></ol><blockquote><p>方案选择</p></blockquote><p>所以，解决方案是非常明确的，就是标准化。</p><p>但如何标准化，目前前端领域没有一个统一且成熟的答案，之所以没有，是因为AB实验是深度绑定业务的，而业务的差异化导致难以在技术领域形成标准。</p><p>可以把每次实验的每个组别都当作是产品提出的一次业务需求，这种需求是极其灵活的，因此难以形成技术领域的标准。</p><p>虽然难以形成技术领域的标准，但形成公司内部的标准却是可行的。</p><p>当然这种标准是多方面的，我这里单从技术的角度聊一聊API的标准化。</p><p>API标准化的重要目标就是要把前端代码当中所有跟AB实验相关的代码从语义的角度进行隔离。</p><p>举例1： 逻辑判断</p><p>举例2： 高阶组件</p><p>这种隔离不仅可以提升开发效率，而且对将来的实验推全奠定了自动化的基础。</p><p>当然，API只是整套SDK的一部分，因为我们的前端代码是散落在不同技术位置的，比如node服务器搭建的BFF、以jQuery为主的活动页面、Webpack搭建的多页应用、Vite搭建的组件库等等等等。</p><p>要适配多种技术场景，我们把SDK分为了底层和上层，底层提供核心API，上层调用底层的API产生多个库，适配不同的技术场景。（见简历）</p><p>总之，整套SDK就是保证无论是哪种技术场景，都能够在其中找到合适的工具。</p><p>比如自动化的实验推全，SDK中有相应的命令行工具，也可以使用它的webpack插件或者vite插件在打包时自动推全。</p><p>比如实验分流，SDK中有相应的工具，会根据用户身份和浏览器指纹以及分流规则、实验状态等信息共同决定用户应该处于哪个实验分组。</p><p>再比如对于CSS代码，SDK中有相应的PostCSS插件，可以识别我们自定义的CSS指令，这些指令是我们单独为AB实验定制的，因此需要开发自定义的插件来解析。</p><blockquote><p>最终效果</p></blockquote><p>总之，有了这套SDK后，我们有过统计，在AB实验的开发效率上提升了70%，并且减少了90%的代码出错几率，同时在代码可读性可维护性上都有大幅度提升。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABT </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传</title>
      <link href="/2024/06/24/da-wen-jian-shang-chuan/"/>
      <url>/2024/06/24/da-wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的SaaS平台中包含企业资料、会议视频等大文件的上传，如果不作特殊处理，将遇到以下问题：</p><ol><li> 网络中断、程序异常退出等问题导致文件上传失败，从而不得不全部重新上传</li><li> 同一文件被不同用户反复上传，白白占用网络和服务器存储资源</li></ol><p>因此，需要一个针对大文件上传的方案来解决上述问题。</p><h2 id="问题和方案"><a href="#问题和方案" class="headerlink" title="问题和方案"></a>问题和方案</h2><p>大文件上传的普遍方案是文件分片上传。</p><p>如果把文件上传看做是一个不可分割的事务，那么分片的目标就是把一个耗时的大事务划分为一个一个的小事务。</p><p>由于公司使用BFF层来承接前端的文件请求，因此需要打通前后端所有跟文件上传的障碍。</p><img src="https://resource.duyiedu.com/yuanjin/202403121503190.png" alt="image-20240312150330145" style=""><p>分片上传的主要障碍集中在：</p><ol><li> 如何减少页面阻塞</li><li> 前后端如何协调</li><li> 代码如何组织</li><li> 前端代码中的复杂逻辑</li><li> BFF代码中的复杂逻辑</li></ol><p>下面分开阐述</p><h3 id="如何减少页面阻塞？"><a href="#如何减少页面阻塞？" class="headerlink" title="如何减少页面阻塞？"></a>如何减少页面阻塞？</h3><p>分片上传的一个首要目标就是要尽量避免相同的分片重复上传。服务器必须要能够识别来自各个客户端的各个上传请求中，是否存在与过去分片相同的上传请求。</p><img src="https://resource.duyiedu.com/yuanjin/202403121520874.png" alt="image-20240312152044755" style=""><p>服务器如何识别哪些分片是相同的呢？</p><p>首先需要对相同下一个准确的定义： 文件内容一样即为相同。</p><p>可是对文件内容进行二进制的对比是一个非常耗时的操作，于是可以选择基于内容的hash来进行对比。</p><blockquote><p>hash是一种算法，可以将任何长度的数据转换为定长的数据，常见的hash算法包括MD5、SHA-1。</p><p>本节课使用MD5进行hash计算，使用第三方库 <a href="https://github.com/satazor/js-spark-md5">Spark-MD5</a>。</p></blockquote><img src="https://resource.duyiedu.com/yuanjin/202403121531402.png" alt="image-20240312153125355" style=""><p>不仅针对分片如此，针对整个文件也是如此。</p><img src="https://resource.duyiedu.com/yuanjin/202403121537105.png" alt="image-20240312153716061" style=""><p>可见，客户端需要承担两件重要的事情：</p><ol><li> 对文件进行分片，并计算每个分片的hash值</li><li> 根据所有分片的hash值，计算整个文件的hash值</li></ol><p>而计算Hash是一件CPU密集型的操作，如果不加处理将会导致长时间阻塞主线程。</p><img src="https://resource.duyiedu.com/yuanjin/202403121600216.png" alt="image-20240312160059174" style=""><p>为了解决这个问题，我们可以对大文件上传做一个大胆的假设：绝大部分的文件上传都是新文件上传。</p><p>有了这个假设，我们就无须等待整体hash的计算结果，直接上传分片即可，同时可以把分片操作使用多线程+异步的方式进行上传处理。</p><img src="https://resource.duyiedu.com/yuanjin/202403121608635.png" alt="image-20240312160813531" style=""><p>这样做的好处是，页面完全无阻塞，也无须等待整体hash即可启动上传，相比于传统方案：</p><ol><li> 对于新文件上传可以缩短整体上传时间，消除页面的阻塞。</li><li> 对于旧文件上传可能会产生一些无效的请求，但这些请求仅传递的是hash，并不真实上传文件数据，所以对网络和服务器影响很小，加之旧文件上传情况相对较少，所以整体影响可以忽略不计。</li></ol><h3 id="前后端如何协调？"><a href="#前后端如何协调？" class="headerlink" title="前后端如何协调？"></a>前后端如何协调？</h3><p>文件上传涉及到前后端的交互，需要建立一个标准的通信协议，通过协议要能完成下面几件核心交互：</p><ol><li> 创建文件</li><li> hash校验</li><li> 分片数据上传</li><li> 分片合并</li></ol><h4 id="创建文件协议"><a href="#创建文件协议" class="headerlink" title="创建文件协议"></a>创建文件协议</h4><p>当客户端发送分片到服务器时，需要告知服务器分片属于哪一次文件上传，因此需要一个唯一标识来标识某一次文件上传。</p><p>创建文件协议就是用于获取文件上传的唯一标识。</p><img src="https://resource.duyiedu.com/yuanjin/202403130832934.png" alt="image-20240313083216884" style=""><ul><li>  <code>uploadToken</code>： 文件上传的唯一标识</li><li>  <code>chunkSize</code>： 分片大小，单位字节</li></ul><h4 id="hash校验协议"><a href="#hash校验协议" class="headerlink" title="hash校验协议"></a>hash校验协议</h4><p>客户端有时需要校验单个分片或整个文件的hash，服务器需要告知客户端它们目前的具体情况。</p><img src="https://resource.duyiedu.com/yuanjin/202403130843811.png" alt="image-20240313084315768" style=""><ul><li>  <code>Upload-Hash-Type</code>： 取值<code>chunk</code>或<code>file</code>，分别代表分片hash和文件整体hash</li><li>  <code>Upload-Hash</code>： 分片或文件的具体hash值</li><li>  <code>hasFile</code>： 指示服务器是否已经存储了对应的分片或文件</li><li>  <code>rest</code>： 当校验文件hash时特有的响应字段， 指示该文件还剩余哪些hash没有上传</li><li>  <code>url</code>： 当校验文件hash时特有的响应字段， 如果该文件已完成上传出现该字段， 表示文件的请求地址</li></ul><h4 id="分片数据上传协议"><a href="#分片数据上传协议" class="headerlink" title="分片数据上传协议"></a>分片数据上传协议</h4><p>通过此协议，上传具体的文件分片数据</p><img src="https://resource.duyiedu.com/yuanjin/202403131025958.png" alt="image-20240313102553900" style=""><h4 id="分片合并协议"><a href="#分片合并协议" class="headerlink" title="分片合并协议"></a>分片合并协议</h4><p>当所有的分片全部上传后，通过此协议请求服务器完成分片合并。</p><img src="https://resource.duyiedu.com/yuanjin/202403131029886.png" alt="image-20240313102931840" style=""><h3 id="代码如何组织？"><a href="#代码如何组织？" class="headerlink" title="代码如何组织？"></a>代码如何组织？</h3><p>大文件上传SDK的搭建分为三层：</p><img src="https://resource.duyiedu.com/yuanjin/202403080930703.png" alt="image-20240308093004656" style=""><ul><li><p>上传协议<br>  约定前后端的通信格式</p></li><li><p>upload-core<br>  基于协议的API，提供协议字段的创建、读取、前后端通用工具函数等核心功能</p></li><li><p>upload-client<br>  应用于客户端的SDK</p></li><li><p>upload-server<br>  应用于BFF的SDK</p></li></ul><h4 id="upload-core中的通用函数"><a href="#upload-core中的通用函数" class="headerlink" title="upload-core中的通用函数"></a>upload-core中的通用函数</h4><p><strong>EventEmitter</strong></p><p>统一前后端涉及到的基于各种事件的处理，使用<strong>发布订阅模式</strong>提供统一的EventEmitter类。</p><blockquote><ol><li> 前端可能出现的各种事件： 上传进度改变事件、上传暂停/恢复事件等等</li><li> 后端可能出现的各种事件： 分片写入完成事件、分片合并完成事件等等</li></ol></blockquote><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">string</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> events<span class="token punctuation">:</span> Map<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span><span class="token keyword">Function</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">on</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> T<span class="token punctuation">,</span> listener<span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">off</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> T<span class="token punctuation">,</span> listener<span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">once</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> T<span class="token punctuation">,</span> listener<span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> onceListener <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">listener</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> onceListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> onceListener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">emit</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> T<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">listener</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>TaskQueue</strong></p><p>为支撑前后端的多任务并发执行，提供TaskQueue类</p><blockquote><ol><li> 前端可能的并发执行： 并发请求</li><li> 后端可能的并发执行： 并发的分片Hash校验</li></ol></blockquote><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 任务构造器</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>  fn<span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务关联的执行函数</span>  payload<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务关联的其他信息</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>fn<span class="token punctuation">:</span> <span class="token keyword">Function</span><span class="token punctuation">,</span> payload<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>payload <span class="token operator">=</span> payload<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行任务</span>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 可并发执行的任务队列</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TaskQueue</span> <span class="token keyword">extends</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span><span class="token string">'start'</span> <span class="token operator">|</span> <span class="token string">'pause'</span> <span class="token operator">|</span> <span class="token string">'drain'</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 待执行的任务</span>  <span class="token keyword">private</span> tasks<span class="token punctuation">:</span> Set<span class="token operator">&lt;</span>Task<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当前正在执行的任务数</span>  <span class="token keyword">private</span> currentCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 任务状态</span>  <span class="token keyword">private</span> status<span class="token punctuation">:</span> <span class="token string">'paused'</span> <span class="token operator">|</span> <span class="token string">'running'</span> <span class="token operator">=</span> <span class="token string">'paused'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最大并发数</span>  <span class="token keyword">private</span> concurrency<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>concurrency<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>concurrency <span class="token operator">=</span> concurrency<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 添加任务</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>tasks<span class="token punctuation">:</span> Task<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> t of tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 添加任务并启动执行</span>  <span class="token function">addAndStart</span><span class="token punctuation">(</span><span class="token operator">...</span>tasks<span class="token punctuation">:</span> Task<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>tasks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 启动任务</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">'running'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务正在进行中，结束</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tasks<span class="token punctuation">.</span>size <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 当前已无任务，触发drain事件</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'drain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置任务状态为running</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'running'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 触发start事件</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 开始执行下一个任务</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 取出第一个任务</span>  <span class="token keyword">private</span> <span class="token function">takeHeadTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> task<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行下一个任务</span>  <span class="token keyword">private</span> <span class="token function">runNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token string">'running'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果整体的任务状态不是running，结束</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentCount <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>concurrency<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 并发数已满，结束</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 取出第一个任务</span>    <span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">takeHeadTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 没有任务了</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'paused'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 暂停执行</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'drain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 触发drain事件</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>currentCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前任务数+1</span>    <span class="token comment" spellcheck="true">// 执行任务</span>    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 任务执行完成后，当前任务数-1，继续执行下一个任务</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>currentCount<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 暂停任务</span>  <span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">'paused'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'pause'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="前端代码中的复杂问题"><a href="#前端代码中的复杂问题" class="headerlink" title="前端代码中的复杂问题"></a>前端代码中的复杂问题</h3><p>前端涉及到两个核心问题：</p><ol><li> 如何对文件分片</li><li> 如何控制请求</li></ol><h4 id="如何对文件分片？"><a href="#如何对文件分片？" class="headerlink" title="如何对文件分片？"></a>如何对文件分片？</h4><p>首先要实现分片对象的处理</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// chunk.ts</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Chunk</span> <span class="token punctuation">{</span>  blob<span class="token punctuation">:</span> Blob<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片的二进制数据</span>  start<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片的起始位置</span>  end<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片的结束位置</span>  hash<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片的hash值</span>  index<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片在文件中的索引</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建一个不带hash的chunk</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createChunk</span><span class="token punctuation">(</span>  file<span class="token punctuation">:</span> File<span class="token punctuation">,</span>  index<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span>  chunkSize<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Chunk <span class="token punctuation">{</span>  <span class="token keyword">const</span> start <span class="token operator">=</span> index <span class="token operator">*</span> chunkSize<span class="token punctuation">;</span>  <span class="token keyword">const</span> end <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> chunkSize<span class="token punctuation">,</span> file<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> blob <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    blob<span class="token punctuation">,</span>    start<span class="token punctuation">,</span>    end<span class="token punctuation">,</span>    hash<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    index<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 计算chunk的hash值</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">calcChunkHash</span><span class="token punctuation">(</span>chunk<span class="token punctuation">:</span> Chunk<span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> spark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SparkMD5<span class="token punctuation">.</span>ArrayBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> fileReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fileReader<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token operator">?</span><span class="token punctuation">.</span>result as ArrayBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>spark<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    fileReader<span class="token punctuation">.</span><span class="token function">readAsArrayBuffer</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，要对整个文件进行分片，分片的方式有很多，比如：</p><ul><li>  普通分片</li><li>  基于多线程的分片</li><li>  基于主线程时间切片的分片（React Fiber）</li><li>  其他分片模式</li></ul><p>考虑到通用性，必须要向上层提供不同的分片模式，同时还要允许上层自定义分片模式，因此在设计上，使用基于抽象类的<strong>模板模式</strong>来完成处理。</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// ChunkSplitor.ts</span><span class="token comment" spellcheck="true">// 分片的相关事件</span><span class="token comment" spellcheck="true">// chunks: 一部分分片产生了</span><span class="token comment" spellcheck="true">// wholeHash: 整个文件的hash计算完成</span><span class="token comment" spellcheck="true">// drain: 所有分片处理完成</span><span class="token keyword">export</span> type ChunkSplitorEvents <span class="token operator">=</span> <span class="token string">'chunks'</span> <span class="token operator">|</span> <span class="token string">'wholeHash'</span> <span class="token operator">|</span> <span class="token string">'drain'</span><span class="token punctuation">;</span><span class="token keyword">export</span> abstract <span class="token keyword">class</span> <span class="token class-name">ChunkSplitor</span> <span class="token keyword">extends</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span>ChunkSplitorEvents<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">protected</span> chunkSize<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片大小（单位字节）</span>  <span class="token keyword">protected</span> file<span class="token punctuation">:</span> File<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 待分片的文件</span>  <span class="token keyword">protected</span> hash<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 整个文件的hash</span>  <span class="token keyword">protected</span> chunks<span class="token punctuation">:</span> Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片列表</span>  <span class="token keyword">private</span> handleChunkCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 已计算hash的分片数量</span>  <span class="token keyword">private</span> spark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SparkMD5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 计算hash的工具</span>  <span class="token keyword">private</span> hasSplited <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否已经分片</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>file<span class="token punctuation">:</span> File<span class="token punctuation">,</span> chunkSize<span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>file <span class="token operator">=</span> file<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>chunkSize <span class="token operator">=</span> chunkSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取分片数组</span>    <span class="token keyword">const</span> chunkCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>file<span class="token punctuation">.</span>size <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chunkSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>chunks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>chunkCount<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">createChunk</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>file<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chunkSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hasSplited<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hasSplited <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span><span class="token string">'chunks'</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> chunksHanlder <span class="token operator">=</span> <span class="token punctuation">(</span>chunks<span class="token punctuation">:</span> Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'chunks'</span><span class="token punctuation">,</span> chunks<span class="token punctuation">)</span><span class="token punctuation">;</span>      chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleChunkCount <span class="token operator">+</span><span class="token operator">=</span> chunks<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChunkCount <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>chunks<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 计算完成</span>        emitter<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token string">'chunks'</span><span class="token punctuation">,</span> chunksHanlder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'wholeHash'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>spark<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>spark<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'drain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'chunks'</span><span class="token punctuation">,</span> chunksHanlder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">calcHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>chunks<span class="token punctuation">,</span> emitter<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 计算每一个分片的hash</span>  abstract <span class="token function">calcHash</span><span class="token punctuation">(</span>chunks<span class="token punctuation">:</span> Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> emitter<span class="token punctuation">:</span> EventEmitter<span class="token operator">&lt;</span><span class="token string">'chunks'</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分片完成后一些需要销毁的工作</span>  abstract <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于此抽象类，即可实现多种形式的分片模式，每种模式只需要继承<code>ChunkSplitor</code>，实现计算分片的hash即可。</p><p>比如，基于多线程的分片类可以非常简单的实现：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// MutilThreadSplitor.ts</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MultiThreadSplitor</span> <span class="token keyword">extends</span> <span class="token class-name">ChunkSplitor</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> workers<span class="token punctuation">:</span> Worker<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>hardwareConcurrency <span class="token operator">||</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>        <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">'./SplitWorker.ts'</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> <span class="token string">'module'</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">calcHash</span><span class="token punctuation">(</span>chunks<span class="token punctuation">:</span> Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> emitter<span class="token punctuation">:</span> EventEmitter<span class="token operator">&lt;</span><span class="token string">'chunks'</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> workerSize <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>chunks<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>workers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>workers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>workers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> start <span class="token operator">=</span> i <span class="token operator">*</span> workerSize<span class="token punctuation">;</span>      <span class="token keyword">const</span> end <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> workerSize<span class="token punctuation">,</span> chunks<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">const</span> workerChunks <span class="token operator">=</span> chunks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>      worker<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>workerChunks<span class="token punctuation">)</span><span class="token punctuation">;</span>      worker<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'chunks'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> worker<span class="token punctuation">.</span><span class="token function">terminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// SplitWorker.ts</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> chunks <span class="token operator">=</span> e<span class="token punctuation">.</span>data as Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chunk of chunks<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">calcChunkHash</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      chunk<span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>      <span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token punctuation">[</span>chunk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何控制请求？"><a href="#如何控制请求？" class="headerlink" title="如何控制请求？"></a>如何控制请求？</h4><p>对请求的控制涉及到多个方面的问题：</p><ol><li><p><strong>如何充分利用带宽</strong><br> 分片上传中涉及到大量的请求发送，这些请求既不能一起发送造成网络阻塞，也不能依次发送浪费带宽资源，因此需要有请求并发控制的机制。<br> <strong>方案</strong>： 利用基础库的TaskQueue实现并发控制</p></li><li><p>如何与上层请求库解耦</p><p> 考虑到通用性，上层应用可能会使用各种请求库来发送请求，因此前端SDK不能绑定任何的请求库。<br> <strong>方案</strong>： 这里使用<strong>策略模式</strong>对请求库解耦。</p></li></ol><p>这个类比较复杂，下面贴出核心代码结构</p><p><code>请求策略</code></p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 请求策略</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">RequestStrategy</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 文件创建请求，返回token</span>  <span class="token function">createFile</span><span class="token punctuation">(</span>file<span class="token punctuation">:</span> File<span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分片上传请求</span>  <span class="token function">uploadChunk</span><span class="token punctuation">(</span>chunk<span class="token punctuation">:</span> Chunk<span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 文件合并请求，返回文件url</span>  <span class="token function">mergeFile</span><span class="token punctuation">(</span>token<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// hash校验请求</span>  patchHash<span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token string">'file'</span> <span class="token operator">|</span> <span class="token string">'chunk'</span><span class="token operator">></span><span class="token punctuation">(</span>    token<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span>    hash<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span>    type<span class="token punctuation">:</span> T  <span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span>    T <span class="token keyword">extends</span> <span class="token string">'file'</span>      <span class="token operator">?</span> <span class="token punctuation">{</span> hasFile<span class="token punctuation">:</span> <span class="token keyword">boolean</span> <span class="token punctuation">}</span>      <span class="token punctuation">:</span> <span class="token punctuation">{</span> hasFile<span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">;</span> rest<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> url<span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">}</span>  <span class="token operator">></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>请求控制</code></p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UploadController</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> requestStrategy<span class="token punctuation">:</span> RequestStrategy<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求策略，没有传递则使用默认策略</span>  <span class="token keyword">private</span> splitStrategy<span class="token punctuation">:</span> ChunkSplitor<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分片策略，没有传递则默认多线程分片</span>  <span class="token keyword">private</span> taskQueue<span class="token punctuation">:</span> TaskQueue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 任务队列</span>  <span class="token comment" spellcheck="true">// 其他属性略</span>  <span class="token comment" spellcheck="true">// 初始化</span>  async <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取文件token</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>token <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>requestStrategy<span class="token punctuation">.</span><span class="token function">createFile</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 分片事件监听</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>splitStrategy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'chunks'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleChunks<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>splitStrategy<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'wholeHash'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleWholeHash<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 分片事件处理</span>  <span class="token keyword">private</span> <span class="token function">handleChunks</span><span class="token punctuation">(</span>chunks<span class="token punctuation">:</span> Chunk<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分片上传任务加入队列</span>    chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>taskQueue<span class="token punctuation">.</span><span class="token function">addAndStart</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>uploadChunk<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> chunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  async <span class="token function">uploadChunk</span><span class="token punctuation">(</span>chunk<span class="token punctuation">:</span> Chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// hash校验</span>    <span class="token keyword">const</span> resp <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>requestStrategy<span class="token punctuation">.</span><span class="token function">patchHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>token<span class="token punctuation">,</span> chunk<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> <span class="token string">'chunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resp<span class="token punctuation">.</span>hasFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 文件已存在</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 分片上传</span>    await <span class="token keyword">this</span><span class="token punctuation">.</span>requestStrategy<span class="token punctuation">.</span><span class="token function">uploadChunk</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>uploadEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 整体hash事件处理</span>  <span class="token keyword">private</span> async <span class="token function">handleWholeHash</span><span class="token punctuation">(</span>hash<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// hash校验</span>    <span class="token keyword">const</span> resp <span class="token operator">=</span> await <span class="token keyword">this</span><span class="token punctuation">.</span>requestStrategy<span class="token punctuation">.</span><span class="token function">patchHash</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>token<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> <span class="token string">'file'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resp<span class="token punctuation">.</span>hasFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 文件已存在</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> resp<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 根据resp.rest重新编排后续任务</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后端代码中的复杂问题"><a href="#后端代码中的复杂问题" class="headerlink" title="后端代码中的复杂问题"></a>后端代码中的复杂问题</h3><p>相对于客户端而言，服务器面临着更大的挑战。</p><h4 id="如何隔离不同的文件上传？"><a href="#如何隔离不同的文件上传？" class="headerlink" title="如何隔离不同的文件上传？"></a>如何隔离不同的文件上传？</h4><p>在创建文件协议中，服务器使用uuid + jwt 生成一个不可篡改的唯一编码，用于标识不同的文件上传。</p><img src="https://resource.duyiedu.com/yuanjin/202403131341028.png" alt="image-20240313134138969" style=""><h4 id="如何保证分片不重复？"><a href="#如何保证分片不重复？" class="headerlink" title="如何保证分片不重复？"></a>如何保证分片不重复？</h4><p>这里的重复是指：</p><ol><li> 不保存重复分片</li><li> 不上传重复分片</li></ol><p>这就要求分片<strong>跨文件唯一</strong>，并且<strong>永不删除</strong></p><img src="https://resource.duyiedu.com/yuanjin/202403131352110.png" alt="image-20240313135216753" style=""><p>也就是说： <strong>服务器并不保存合并之后的文件，仅记录文件中的分片顺序</strong></p><h4 id="合并分片到底做什么？"><a href="#合并分片到底做什么？" class="headerlink" title="合并分片到底做什么？"></a>合并分片到底做什么？</h4><p>合并会造成很多问题，最主要的是：</p><ol><li> 极其耗时</li><li> 数据冗余</li></ol><p>所以服务器并不发生真正的合并，而是在数据库中记录文件中包含的分片。</p><p>因此，合并操作时，服务器仅做简单的处理：</p><ol><li> 校验文件大小</li><li> 校验文件hash</li><li> 标记文件状态</li><li> 生成文件访问地址</li><li> …</li></ol><p>以上操作效率极高</p><h4 id="访问文件怎么办？"><a href="#访问文件怎么办？" class="headerlink" title="访问文件怎么办？"></a>访问文件怎么办？</h4><p>由于服务器并未发生真正的文件合并，当后续请求该文件时，服务器需要动态处理，具体做法是：</p><ol><li> 服务器收到对文件的请求，并在数据库中找到了对应的文件</li><li> 服务器读取文件的所有分片ID，依次找到对应的分片文件</li><li> 服务器利用TaskQueue的并发控制能力，逐步产生文件读取流，并利用管道直接输出到网络I/O</li></ol><h3 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h3><p>如果使用S3进行大文件上传，要注意分片数量，<strong>最大10000片</strong></p><h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p><strong>项目名</strong>： &lt;写你做过的真实项目&gt;</p><p><strong>岗位</strong>： 中级 / 高级 前端工程师</p><p><strong>项目介绍</strong>：</p><p>介绍你的真实项目</p><p><strong>项目职责</strong>：</p><p>介绍你的项目职责</p><ul><li>  参与项目的通用库开发</li></ul><p><strong>项目亮点</strong>：</p><p>从0到1开发整个upload-sdk，该SDK为所有文件上传特别是<strong>大文件上传</strong>的场景提供前后端的支撑，统一了所有文件上传的开发方式，完成了从<strong>底层协议</strong>、到<strong>工具类</strong>、到<strong>前端组件</strong>、再到<strong>后端中间件</strong>的开发。</p><p>在实现层面，为保证使用的灵活性，利用多种<strong>设计模式</strong>完成了SDK和上层应用的完全解耦，并对服务器的存储结构进行了精细的设计，保证了文件存储和传输的唯一性。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p><strong>请讲讲你是如何实现大文件上传的</strong></p><blockquote><p>方案选择</p></blockquote><p>大文件上传的普遍性方案是文件分片，文件分片其实就是把整个文件上传的大事务打散为一个一个分片上传的小事务，从而降低上传失败的风险。</p><p>整个大文件上传的实现涉及到诸多的技术细节。</p><p>比如底层协议标准如何制定，协议标准决定了前后端如何交互，也就决定了前后端代码如何开发。</p><p>除了协议之外，还涉及到前端如何进行并发控制，如何高效的分片，以及涉及到后端如何存储分片，如何高效合并分片，如何保证分片的唯一性等等等等。</p><p>诸多的问题吧，市面上没有形成统一的解决方案，虽然公有云上的OSS有各自的实现方案，但考虑到我们的产品可能会部署到客户的私有云上，所以最稳妥的办法还是自行实现整个大文件上传。</p><blockquote><p>技术实现</p></blockquote><p><strong>我首先设计的是整个上传流程</strong>。</p><p>传统的大文件上传都是在客户端先完成所有的分片，然后计算每个分片和完整的文件hash，再使用hash和服务器换取当前文件的信息。</p><p>由于hash的计算是CPU密集型的操作，这样一来就会导致长时间的客户端阻塞，虽然可以使用Web Worker来加速hash的计算，但经过我的测试，即便是使用了多线程，某些超大文件比如上了10个G的文件，在配置不太好的客户机上计算时长可以超过30秒，这是无法接受的。</p><p>因此，我对上传流程进行了优化，我假定大部分文件上传都是一个新文件上传，于是在流程上，我允许用户在获得文件完整hash之前直接上传分片，这样一来，几乎可以做到零延时的上传，等到文件整体hash计算出来之后，再向服务器补充hash数据。</p><p><strong>基于这样的流程，于是我设计了一套标准化的文件上传协议</strong></p><p>协议主要包含四个通信标准：</p><ol><li> 创建文件协议： 前端使用HEAD请求向服务器提交文件基本信息，换取上传唯一token，后续的请求必须携带此token</li><li> hash校验协议： 前端把某个分片hash或者是整个文件hash发送给服务器，得到分片和文件的状态信息</li><li> 分片上传协议： 前端将分片的二进制数据发送到服务器存储</li><li> 分片合并协议： 前端提示服务器可以完成分片合并了</li></ol><p><strong>设计好协议后，接下来就需要落实到代码的实现上</strong></p><p>在前端部分主要问题集中在两块： 如何分片 和 如何控制请求流程</p><p>首先是如何分片，考虑到不同的场景可能选择不同的分片模式，比如多线程分片，比如基于时间切片（类似于React Fiber）的分片，甚至是由上层应用自行定义的分片模式。</p><p>于是在实现分片逻辑时，我使用了模版模式，利用TS的抽象类定义好分片的整体流程，具体的子类仅需实现分片hash计算即可，这样一来就可以保持极高的灵活度。</p><p>在请求流程控制层面，由于有诸多请求需要发送，因此我开发了一套并发请求控制类以充分的利用网络带宽。</p><p>另外，由于请求过程中需要向上层抛出各种钩子，比如进度的变化，请求状态的变化等等，对这一块，我使用了发布订阅模式编写了通用的EventEmitter类，这样可以在请求过程中抛出各种事件，上层应用通过监听事件完成处理。</p><p><strong>当然整个系统复杂度最高的还是在后端</strong></p><p>由于我们这个项目有BFF层，需要在BFF层完成文件处理，因此我还需要针对服务器编写相应代码。</p><p>服务器最大的挑战就是如何保证每个分片的唯一性，这种唯一性即包含存储的唯一性，也包含传输的唯一性。</p><p>存储的唯一性保证了分片不会重复保存，避免了数据的冗余。</p><p>传输的唯一性保证了分片不会重复上传，避免了通信的冗余。</p><p>要保证分片不会重复保存，就必须让分片和文件解耦，分片是分片，文件是文件，分片独立保存，不从属于任何文件，文件独立记录，按照顺序依次指向不同分片，这样一来，哪怕出现两个不同文件拥有相同分片的场景，也不会在服务器出现重复存储的问题，因为分片是独立于文件的。</p><p>而要保证分片不会重复上传，就必须保证分片永不删除，如果在合并文件后删除了分片，就会导致下一次有相同分片上传时服务器找不到对应的分片文件，就必须重复上传，因此分片永不删除。</p><p>最后就是合并分片的逻辑，我考虑到如果真正的把分片文件合并成一个大文件，大文件的所有数据实际上都是冗余的，而且整个合并过程极其耗时，因此我做了这样的处理。</p><p>当收到合并请求时，服务器其实仅仅做一些简单的校验即可，比如文件大小、分片数量等校验，而不进行真正的合并，仅在数据库mongodb中更新该文件的状态并生成文件访问的url地址即可。</p><p>等到用户真正访问文件时，我根据数据库中对应文件的分片记录，使用文件流依次读取分片数据，用流管道直接响应给客户端即可。</p><p>这样一来整个合并效率和文件访问效率都极高，同时服务器的存储不会有任何冗余。</p><p>以上，就是我整个上传SDK的实现思路，其他还有很多细节，但大致上就是这样。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 实践 </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 策略模式 </tag>
            
            <tag> 模板模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求库的封装</title>
      <link href="/2024/06/24/qing-qiu-ku-de-feng-zhuang/"/>
      <url>/2024/06/24/qing-qiu-ku-de-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="请求库的封装"><a href="#请求库的封装" class="headerlink" title="请求库的封装"></a>请求库的封装</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>虽然前端具有诸多成熟的请求库，但在实际项目开发中发现，它们很难完全契合实际的开发需求。</p><p><strong>axios</strong></p><p>axios虽然很成熟，但它只是一个基础库，没有提供诸多的上层功能，比如：</p><ol><li>请求重试</li><li>请求缓存</li><li>请求幂等</li><li>请求串行</li><li>请求并发</li><li>…</li></ol><p><strong>VueRequest / SWR</strong></p><p>它们虽然提供的功能很多，但仍然存在诸多问题：</p><ol><li>与上层框架过度绑定导致开发场景受限，也无法提供统一的API</li><li>成熟度不够，issue的回复也难以做到及时，存在一定风险</li><li>它们没有聚合基础请求库，仍然需要手动整合</li></ol><p><strong>除此之外更重要的是</strong></p><p>公共库不包含公司内部制定的协议规范，即便使用公共库，也必须针对它们做二次封装。</p><p><strong>综上，需要自行封装一套适配公司业务的前端请求库</strong></p><h2 id="方案和实现"><a href="#方案和实现" class="headerlink" title="方案和实现"></a>方案和实现</h2><h3 id="库结构的宏观设计"><a href="#库结构的宏观设计" class="headerlink" title="库结构的宏观设计"></a>库结构的宏观设计</h3><p><img src="https://resource.duyiedu.com/yuanjin/202403151545374.svg" alt="结构"></p><p>整个库结构包含三层，从下往上依次是：</p><ul><li><code>请求实现层</code>： 提供请求基本功能</li><li><code>request-core</code>： 提供网络上层控制，比如请求串行、请求并行、请求重试、请求防重等功能</li><li><code>request-bus</code>： 为请求绑定业务功能，该层接入公司内部协议规范和接口文档，向外提供业务接口API</li></ul><blockquote><p>层是一种对代码结构的逻辑划分，在具体实现上可以有多种方式：</p><ul><li>每个层一个npm包</li><li>每个层一个项目子文件夹</li><li>…</li></ul></blockquote><p><strong>优化设计</strong></p><p>在三层中，请求实现层的实现有多种方式：</p><ul><li>基于<code>XHR</code>原生</li><li>基于<code>fetch</code>原生</li><li>基于<code>axios</code>等第三方库</li></ul><p>这种实现的多样性可能导致这一次层的不稳定，而<code>request-imp</code>是基础层，它的不稳性会传导到上一层。</p><p>所以必须寻求一种方案来隔离这种不稳定性。</p><p>我们可以基于DIP（Dependence Inversion Principle，依赖倒置原则），彻底将<code>request-core</code>和请求的实现解耦，而<code>typescript</code>的类型系统让这一切的落地成为了可能。</p><p>于是结构演变为：</p><p><img src="https://resource.duyiedu.com/yuanjin/202403151501992.svg" alt="优化结构"></p><p>下面是示意代码</p><p><code>request-core</code>代码示意</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 定义接口，不负责实现</span><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Requestor</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">,</span> options<span class="token punctuation">:</span>RequestOptions<span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span>Response<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 略...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 本模块的大部分功能都需要使用到requestor</span><span class="token keyword">let</span> req： Requestor<span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">inject</span><span class="token punctuation">(</span>requestor： Requestor<span class="token punctuation">)</span><span class="token punctuation">{</span>  req <span class="token operator">=</span> requestor<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useRequestor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> req<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建一个可以重试的请求</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createRetryRequestor</span><span class="token punctuation">(</span>maxCount <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">useRequestor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步配置req</span>  <span class="token keyword">return</span> req<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建一个并发请求</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createParallelRequestor</span><span class="token punctuation">(</span>maxCount <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">useRequestor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 进一步配置req</span>  <span class="token keyword">return</span> req<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>request-axios-imp</code>代码示意</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> Requestor <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'request-core'</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token punctuation">;</span><span class="token keyword">const</span> ins <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> requestor<span class="token punctuation">:</span> XRequestor <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用axios实现</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 其他请求方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>request-bus</code>示意代码</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// 为request-core注入requestor的具体实现</span><span class="token keyword">import</span> <span class="token punctuation">{</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'request-core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> requestor <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'request-axios-imp'</span><span class="token punctuation">;</span><span class="token function">inject</span><span class="token punctuation">(</span>requestor<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，当将来如果实现改变时，无须对<code>request-core</code>做任何改动，仅需新增实现并改变依赖即可。</p><p>比如，将来如果改为使用<code>fetch api</code>完成请求，仅需做以下改动：</p><p>新增库<code>request-fetch-imp</code></p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> Requestor <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'request-core'</span><span class="token keyword">export</span> requestor<span class="token punctuation">:</span> Requestor <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用fetch实现</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用fetch实现</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 其他请求方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改变<code>request-bus</code>的依赖</p><pre class="line-numbers language-diff"><code class="language-diff"><span class="token deleted">- import { requestor } from 'request-axios-imp';</span><span class="token inserted">+ import { requestor } from 'request-fetch-imp';</span>inject(requestor);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h3><p>请求缓存是指创建一个带有缓存的请求，当没有命中缓存时发送请求并缓存结果，当有缓存时直接返回缓存。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">createCacheRequestor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>req<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求</span>req<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用缓存</span>req<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 请求</span>req<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用缓存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要实现此功能需要考虑几个核心问题：</p><p><strong>请求结果怎么存？存在哪？缓存键是什么？</strong></p><p>我们希望用户能够指定缓存方案（内存/持久化），同时也能够指定缓存键。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">createCacheRequestor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  key<span class="token punctuation">:</span> <span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// config为某次请求的配置</span>      <span class="token keyword">return</span> config<span class="token punctuation">.</span>pathname<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用pathname作为缓存键</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  persist<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 是否开启持久化缓存                     </span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存储有多种方案，不同的方案能够存储的格式不同、支持的功能不同、使用的API不同、兼容性不同。</p><p>为了抹平这种差异，避免将来存储方案变动时对其他代码造成影响，需要设计一个稳定的接口来屏蔽方案间的差异。</p><p><img src="https://resource.duyiedu.com/yuanjin/202403161148200.svg" alt="存储方案"></p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">CacheStore</span><span class="token punctuation">{</span>  <span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">boolean</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token keyword">set</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token operator">...</span>values<span class="token punctuation">:</span> T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>  <span class="token keyword">get</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Promise<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 其他字段</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useCacheStore</span><span class="token punctuation">(</span>isPersist<span class="token punctuation">)</span><span class="token punctuation">:</span> CacheStore<span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>！isPersist<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createMemoryStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createStorageStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>缓存何时失效？基于时间还是其他条件？</strong></p><p>我们希望用户能够指定缓存如何失效</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">createCacheRequestor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  duration<span class="token punctuation">:</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指示缓存的时间，单位毫秒</span>  <span class="token function">isValid</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 自定义缓存是否有效，提供该配置后，duration配置失效</span>    <span class="token comment" spellcheck="true">// key表示缓存键， config表示此次请求配置</span>    <span class="token comment" spellcheck="true">// 返回true表示缓存有效，返回false缓存无效。</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如何实现？</strong></p><p>核心逻辑</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createCacheRequestor</span><span class="token punctuation">(</span>cacheOptions<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token function">normalizeOptions</span><span class="token punctuation">(</span>cacheOptions<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 参数归一化</span>  <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useCacheStore</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>persist<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用缓存仓库</span>  <span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">useRequestor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得请求实例</span>  <span class="token comment" spellcheck="true">// 对请求进行配置（见后）</span>  <span class="token keyword">return</span> req<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 对请求进行配置</span><span class="token comment" spellcheck="true">// 注册请求发送前的事件</span>req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'beforeRequest'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">const</span> key <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得缓存键</span>  <span class="token keyword">const</span> hasKey <span class="token operator">=</span> <span class="token keyword">await</span> store<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否存在缓存</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>hasKey <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 存在缓存并且缓存有效</span>    <span class="token comment" spellcheck="true">// 返回缓存结果</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'responseBody'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>config<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">const</span> key <span class="token operator">=</span> options<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得缓存键</span>  store<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> resp<span class="token punctuation">.</span><span class="token function">toPlain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="请求幂等"><a href="#请求幂等" class="headerlink" title="请求幂等"></a>请求幂等</h3><p>幂等性是一个数学概念，常见于抽象代数</p><p>$f(n) = 1^n$ 无论n的值是多少，f(n)不变为1</p><p>在网络请求中，很多接口都要求幂等性，比如支付，同一订单多次支付和一次支付对用户余额的影响应该是一样的。</p><p>要解决这一问题，就必须保证： <strong>要求幂等的请求不能重复提交</strong></p><p>这里的关键问题就在于定义什么是<strong>重复</strong>？</p><p>我们可以把<strong>重复</strong>定义为： <strong>请求方法、请求头、请求体完全一致</strong></p><p>因此，我们可以使用<code>hash</code>将它们编码成一个字符串。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">hashRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> spark <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SparkMD5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token punctuation">{</span>    spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  spark<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> spark<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当请求幂等时，直接返回缓存结果即可</p><p>在实现上，可以直接利用缓存功能实现</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createIdempotentRequestor</span><span class="token punctuation">(</span>genKey<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">createCacheRequestor</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    key<span class="token punctuation">:</span> <span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> genKey <span class="token operator">?</span><span class="token function">genKey</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token function">hashRequest</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">,</span>    persist<span class="token punctuation">:</span> <span class="token boolean">false</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="样板代码"><a href="#样板代码" class="headerlink" title="样板代码"></a>样板代码</h3><p>公司的API接口数量庞大并且时常变化，如果<code>request-bus</code>层全部人工处理不仅耗时，而且容易出错。</p><p>可以通过一些标准化的工具让整个过程自动化。</p><img src="https://resource.duyiedu.com/yuanjin/202403161329435.svg" alt="样板代码的生成" style="zoom:50%;"><p><strong>接口平台</strong></p><p>公司自研了一套接口平台，通过接口平台可以自定义一些字段</p><p><img src="https://resource.duyiedu.com/yuanjin/202403161257722.png" alt="image-20240316125736628"></p><p>这样一来，制定接口文档时即可设置对应字段</p><p><img src="https://resource.duyiedu.com/yuanjin/202403161300878.png" alt="image-20240316130059833"></p><p>同时，接口平台提供了生成标准格式的API，通过请求API即可生成标准的JSON描述文件</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"endpoints"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"article"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"publishArticle"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/api/article"</span><span class="token punctuation">,</span>        <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"发布文章"</span><span class="token punctuation">,</span>        <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>        <span class="token property">"auth"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"idempotent"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"cache"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"pager"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        // 其他字段      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"getArticles"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/api/article"</span><span class="token punctuation">,</span>        <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"获取文章"</span><span class="token punctuation">,</span>        <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"GET"</span><span class="token punctuation">,</span>        <span class="token property">"auth"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"idempotent"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"cache"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token property">"pager"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        // 其他字段      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，就为自动化生成样板代码提供了可能</p><p><strong>样板代码的生成</strong></p><p>我们使用node开发了命令行工具<code>request-templet-cli</code>，用于样板代码的生成</p><p>上面的json格式生成的样板代码如下：</p><pre class="line-numbers language-ts"><code class="language-ts"><span class="token comment" spellcheck="true">// request-bus/templet/article.ts</span><span class="token keyword">import</span> <span class="token punctuation">{</span> createIdempotentRequest <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'request-core'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 发布文章 */</span><span class="token keyword">export</span> <span class="token keyword">const</span> publishArticle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token function">createIdempotentRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> async <span class="token punctuation">(</span>article<span class="token punctuation">:</span> Article<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> req<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/api/article'</span><span class="token punctuation">,</span> article<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resp<span class="token operator">=</span><span class="token operator">></span>resp<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 获取文章 */</span><span class="token keyword">export</span> <span class="token keyword">const</span> getArticles <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> async <span class="token punctuation">(</span>page<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> size<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> req<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/api/article'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      params<span class="token punctuation">:</span><span class="token punctuation">{</span>        page<span class="token punctuation">,</span>        size      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resp<span class="token operator">=</span><span class="token operator">></span>resp<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>补丁</strong></p><p>有时候样板代码可能不能满足需求，需要手动进行改动。</p><p>我们可以使用打补丁的方式去修改样板代码，做法非常简单。</p><p>&lt;见demo&gt;</p><h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p><strong>项目名</strong>： &lt;写你做过的真实项目&gt;</p><p><strong>岗位</strong>： 中级 / 高级 前端工程师</p><p><strong>项目介绍</strong>： </p><p>介绍你的真实项目</p><p><strong>项目职责</strong>：</p><p>介绍你的项目职责</p><ul><li>参与项目的通用库开发</li></ul><p><strong>项目亮点</strong>：</p><p>从0到1开发整个请求库，以适配项目开发中遇到的所有请求场景，诸如请求并发、串行、幂等、缓存等。同时包含自动化工具，用于根据接口文档生成请求样板代码。</p><p>请求库不仅完全消除了不同框架间重复的请求代码，极大的缩短了接口联调的时间，为业务开发提效30%，同时带来了更高的可维护性。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p><strong>请讲讲你是如何实现请求库的</strong></p><blockquote><p>方案选择</p></blockquote><p>首先我考虑的是实现的必要性。</p><p>前端本身存在诸多的请求库，像成熟度比较高的axios，但它们都是一些基础库，没有提供上层功能，比如请求并发、请求重试、请求幂等这些都没有。</p><p>另外像一些上层的请求库倒是有这些功能，比如VueRequest，SWR，但它们都和具体的框架绑定了，并且没有提供请求的基础功能，而且它们之间使用风格和功能点都有差异。</p><p>更重要的一点是，市面上的公共库不可能提供基于公司内部协议的封装。</p><p>所以我不得不考虑重新实现基于公司内部业务的通用请求库。</p><blockquote><p>技术实现</p></blockquote><p>在实现层面，我首先考虑的是请求库的整体结构。</p><p>我把请求库分为三层，从下到上依次是请求基础库，负责发送请求的基本功能，然后是请求核心库，负责实现各种上层逻辑，比如并发等等，最上层是请求业务库，负责在代码层面封装公司内部协议。</p><p>在结构上，考虑到请求基础库的具体实现方式可能有变动，必须由xhr换成axios或者fetch，为了减少变动对上层代码造成的改动，我应用DIP原则，参考了后端的IOC和DI，让核心库不依赖具体的请求基础库，核心库仅提供TS接口，请求基础库可以基于接口提供不同的实现方式，在业务库注入具体实现即可，这样一来，就彻底隔离了请求的具体实现，将来实现变动后可以轻易的接入。</p><p>另外，上层业务库由于深度绑定公司内部的接口文档，而我们项目中的接口数量非常庞大，为了减少开发和维护成本，我用node实现了一个自动化工具，通过解析接口标准文档，自动为每个接口生成请求样板代码，并且考虑到某些样板代码可能不符合实际需要，我制定了一种可以基于样板代码打补丁的开发方式。这样既减少了开发量，同时也保证了灵活度。</p><blockquote><p>落地效果</p></blockquote><p>以上就是大体情况，里面细节还很多就不一一列举了。后续我还在请求库基础上进一步封装了针对各种前端框架的请求库，那都是很薄的一层，比较简单就不详细说了。</p><p>整个请求库的落地效果还是很亮眼的，业务开发人员再也无须关心任何的请求，只需调用请求库的业务函数即可，无须关心内部的并发、幂等这些复杂问题，这些事情对业务开发人员完全无感。</p><p>整个请求库为公司的业务开发带来30%的效率提升，并依靠自动生成的样板代码，减少了50%的接口联调的时间。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 网络 </tag>
            
            <tag> 请求库封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>针对特定问题的首屏优化</title>
      <link href="/2024/06/24/shou-ping-you-hua/"/>
      <url>/2024/06/24/shou-ping-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司的产品面向的是企业用户，大部分企业用户会选择对产品进行私有化部署。</p><p>企业对产品的需求是差异化的，因此公司研发了一套低码平台方便客户对产品进行差异化定制。</p><p>客户通过低码平台的定制会产生JS文件，这些JS文件会在运行时加载。</p><img src="https://resource.duyiedu.com/yuanjin/202403191118138.svg" alt="差异化部署" style="zoom:50%;"><p>大量客户反馈首屏等待时间过长的问题，需要制定针对性的优化策略解决问题。</p><p>而要针对性的优化必须要先弄清楚目前的性能热点在哪里，因此，我们将整个优化过程分为三步：</p><ol><li>问题的收集与分析</li><li>措施的制定与实施</li><li>方案的部署与反馈</li></ol><p>以上三步可反复轮询，直到问题解决。</p><h2 id="问题的收集与分析"><a href="#问题的收集与分析" class="headerlink" title="问题的收集与分析"></a>问题的收集与分析</h2><p>这一步的目标是要准确的找到客户侧的问题究竟在哪，找不到问题就无法针对性的制定优化措施。</p><p>而要找到问题并不容易，根据过往经验，大系统的优化问题定位往往需要几个环节的反复进行。</p><img src="https://resource.duyiedu.com/yuanjin/202403200927976.svg" alt="问题收集和分析" style="zoom:50%;"><p>可是问题发生在客户侧，而客户侧的系统不直接暴露到公网，因此收集问题的环节就非常麻烦。</p><p>因此，我们搭建了一套客户侧数据上报的流程，让客户可以安全的把性能数据推送到我们的数据中心。</p><img src="https://resource.duyiedu.com/yuanjin/202403200948658.svg" alt="数据上报" style="zoom:50%;"><p>制定这套流程的初衷，不仅是为了方便收集目前特定用户的性能问题，更重要的是可以收集任何客户反馈的任何问题。</p><p>要落实这一系列流程，需要在技术面提供多方面的支持：</p><ol><li>服务监控系统的更改（前端、后端）</li><li>数据脱敏（大数据）</li><li>数据展示（前端）</li><li>问题实验室（前端、BFF）</li></ol><p>最终，经过几轮测试，问题被清晰的定位：</p><ul><li>HTTP1.1协议效率低下的问题<ul><li>队头阻塞</li><li>头部臃肿</li></ul></li><li>大量的JS代码重复</li><li>大量JS代码无差别加载</li><li>大量的API网络请求</li></ul><h2 id="措施的制定与实施"><a href="#措施的制定与实施" class="headerlink" title="措施的制定与实施"></a>措施的制定与实施</h2><h3 id="针对HTTP1-1的优化措施"><a href="#针对HTTP1-1的优化措施" class="headerlink" title="针对HTTP1.1的优化措施"></a>针对HTTP1.1的优化措施</h3><p><strong>队头阻塞问题</strong></p><img src="http://mdrs.yuanjin.tech/img/20211027133404.png" alt="image-20211027133404730" style="zoom:30%;" align="left"><img src="http://mdrs.yuanjin.tech/img/20211026175005.png" alt="image-20211026175005607" style="zoom:30%;" align="left"><p>针对这一问题，没有别的办法，只能多开域名来解决。</p><blockquote><p>浏览器针对同一域名可以支持最多6个TCP并发连接，超越这个数字后将发生队头阻塞</p></blockquote><img src="https://resource.duyiedu.com/yuanjin/202403201116488.svg" alt="解决队头阻塞" style="zoom:50%;"><img src="https://resource.duyiedu.com/yuanjin/202403201122337.svg" alt="解决队头阻塞-AJAX" style="zoom:50%;"><p><strong>头部臃肿</strong></p><p>由于HTTP1.1不支持头部压缩，而发送的请求中包含大量的自定义头部，于是我们借鉴了HTTP2的头部压缩方式，对自定义头部进行了压缩处理。</p><p><img src="http://mdrs.yuanjin.tech/img/20211027132744.png" alt="image-20211027132744018"></p><h3 id="针对重复代码的优化措施"><a href="#针对重复代码的优化措施" class="headerlink" title="针对重复代码的优化措施"></a>针对重复代码的优化措施</h3><p>客户侧会产生巨量的差异化JS文件，每个JS文件的产生逻辑非常简单：</p><img src="https://resource.duyiedu.com/yuanjin/202403201136584.svg" alt="差异化JS的产生" style="zoom:50%;"><p>结果就是客户侧保存了大量JS代码文件，并且代码文件中出现了大量重复代码。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// g-d8a65e.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  formItems<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 其他差异配置,</span>      <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 代码段a</span>        <span class="token comment" spellcheck="true">// 其他差异代码段</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 代码段a</span>        <span class="token comment" spellcheck="true">// 其他差异代码段</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// g-e218fa.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  formItems<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 其他差异配置,</span>      <span class="token function">validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 代码段a</span>        <span class="token comment" spellcheck="true">// 其他差异代码段</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 代码段a</span>        <span class="token comment" spellcheck="true">// 其他差异代码段</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较容易想到的解决办法，是把那些有可能出现差异的代码提取到公共代码中。</p><img src="https://resource.duyiedu.com/yuanjin/202403201148655.svg" alt="解决重复代码-方案1" style="zoom:50%;"><p>这种方案除了逻辑简单，根本无法实施，主要原因是：</p><ol><li>很难知道客户侧会产生哪些重复代码</li><li>如果把所有可能都枚举到公共代码中，会产生大量的无效代码</li></ol><p>因此，对重复代码的提取必须动态完成。</p><img src="https://resource.duyiedu.com/yuanjin/202403201326133.svg" alt="解决重复代码-方案2" style="zoom:50%;"><p>这里面有两个关键问题：</p><ol><li>如何找到代码中的重复？</li><li>何时提重？</li></ol><h4 id="如何找到重复？"><a href="#如何找到重复？" class="headerlink" title="如何找到重复？"></a>如何找到重复？</h4><p>考虑下面两段代码，如何找到重复？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代码片段1</span><span class="token keyword">const</span> selectSource <span class="token operator">=</span> <span class="token string">"department"</span><span class="token punctuation">;</span><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span>selectSource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bindSelectSource</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  source<span class="token punctuation">,</span>  label<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>  value<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 代码片段2</span><span class="token keyword">const</span> selectSource <span class="token operator">=</span> <span class="token string">"task"</span><span class="token punctuation">;</span><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span>selectSource<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bindSelectSource</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  source<span class="token punctuation">,</span>  label<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>  value<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过AST分析，可以得到两棵树</p><p><img src="https://resource.duyiedu.com/yuanjin/202403201449001.png" alt="对比"></p><p>我们的目标是：找出两棵树<strong>连续</strong>的<strong>相同结构</strong>的节点，将它们提取成函数，同时把相同结构中的不同点提取为函数参数。</p><p>大致思路是：</p><ol><li>计算每个节点的结构hash</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 变量声明节点的hash求值</span><span class="token keyword">class</span> <span class="token class-name">VariableDeclarationNode</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...省略其他代码</span>    <span class="token function">hash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      md5<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>kind<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// const、var、let</span>    md5<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 变量名</span>    md5<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>init<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始值类型： 字面量、表达式、变量</span>    <span class="token keyword">return</span> md5<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 得到hash</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>将AST树信息入库（含hash结果）</li></ol><p>库中的信息大致如下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token property">"filename"</span><span class="token operator">:</span> <span class="token string">"1.js"</span><span class="token punctuation">,</span>    <span class="token property">"struct"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        hash<span class="token operator">:</span> <span class="token string">"....."</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        hash<span class="token operator">:</span> <span class="token string">"....."</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"filename"</span><span class="token operator">:</span> <span class="token string">"2.js"</span><span class="token punctuation">,</span>    <span class="token property">"struct"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        hash<span class="token operator">:</span> <span class="token string">"....."</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        hash<span class="token operator">:</span> <span class="token string">"....."</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> hash<span class="token operator">:</span> <span class="token string">"...."</span><span class="token punctuation">,</span> children<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>寻找库中出现的连续的、hash一致的节点进行提重。</li><li>将差异点提取为参数</li></ol><p>最终提重的结果如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// repeating.js</span><span class="token comment" spellcheck="true">// 自动提重后的代码</span><span class="token keyword">function</span> <span class="token function">rp_2d4ef</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> selectSource <span class="token operator">=</span> p1<span class="token punctuation">;</span>  <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span>selectSource<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">bindSelectSource</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    source<span class="token punctuation">,</span>    label<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>s<span class="token punctuation">.</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后代码片段被修改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 代码片段1</span><span class="token function">rp_2d4ef</span><span class="token punctuation">(</span><span class="token string">"department"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 代码片段2</span><span class="token function">rp_2d4ef</span><span class="token punctuation">(</span><span class="token string">"task"</span><span class="token punctuation">,</span> <span class="token string">"title"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="何时提重？"><a href="#何时提重？" class="headerlink" title="何时提重？"></a>何时提重？</h4><p>为了保证效率，提重可以异步延时执行，也可以开启计划任务在服务器空闲时执行，也可以管理员手动执行。</p><h3 id="针对无差别加载的优化措施"><a href="#针对无差别加载的优化措施" class="headerlink" title="针对无差别加载的优化措施"></a>针对无差别加载的优化措施</h3><p>过去，用户侧自定义产生的差异JS都是在首屏全部加载的，实际上，很多JS并不需要在当前页面运行。</p><p>因此，需要对这些JS进行差别化加载，视口内需要的先加载，不需要的延迟加载。</p><p>这就需要做到两件事：</p><ol><li>定义每个功能页视口内组件</li><li>标识每个JS文件对应到哪个组件（已有功能）</li></ol><p>此时很容易完成，不再详细阐述。</p><h3 id="针对大量API网络请求的优化措施"><a href="#针对大量API网络请求的优化措施" class="headerlink" title="针对大量API网络请求的优化措施"></a>针对大量API网络请求的优化措施</h3><p>大量的首屏请求均来自自动化生成的差异代码，其中包含大量的GET重复请求。</p><p>我们针对性的加入了短时缓存，让相同的请求走缓存通道。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 自动生成的代码</span><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getSelectSource</span><span class="token punctuation">(</span><span class="token string">'department'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 修改为</span><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">withCache</span><span class="token punctuation">(</span>getSelectSource<span class="token punctuation">,</span> <span class="token string">'department'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">withCache</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> caches <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>caches<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 无缓存，初始化</span>    map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> caches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> cache <span class="token operator">=</span> caches<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token operator">></span><span class="token function">isSameArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> c<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 按参数查找缓存</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cache<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 无缓存，初始化</span>    caches<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cache <span class="token operator">=</span> <span class="token punctuation">{</span>      args<span class="token punctuation">,</span>      value<span class="token punctuation">:</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> cache<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> CACHE_DURATION <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  map <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> CACHE_DURATION<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p><strong>项目名</strong>： &lt;写你做过的真实项目&gt;</p><p><strong>岗位</strong>： 中级 / 高级 前端工程师 / 前端架构师</p><p><strong>项目介绍</strong>： </p><p>介绍你的真实项目</p><p><strong>项目职责</strong>：</p><p>介绍你的项目职责</p><ul><li>负责/参与项目优化方案的制定和实施</li></ul><p><strong>项目亮点</strong>：</p><p>针对客户反馈的首屏慢问题制定了详细的优化策略并完整参与了优化措施的落地。</p><p>通过数据埋点收集和定位性能问题，通过本地实验室复现问题。针对问题制定了具体的优化措施，包括解决了HTTP1.1的队头阻塞和头部无压缩的问题，以及开发了自动化工具完成自动代码提重从而压缩包体积等诸多手段。</p><p>经过优化后的代码LCP时间降低了80%，同时提供了一套完整标准的工单流程。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p><strong>请讲讲你是如何首屏优化的</strong></p><blockquote><p>策略的制定</p></blockquote><p>无论是做哪一种优化，都需要经过三个步骤：定位问题、解决问题、测试反馈。</p><p>很多时候都是在这三个步骤间反复轮询。</p><p>而我们项目的难点在于我们的产品很多是私有化部署，并且用户可以通过低码平台实现产品的高度定制。也就是说我们无法知晓客户定制了哪些内容，由定制产生了多少JS文件，无法复现客户的运行环境，无法复现客户的问题。</p><p>所以我首先是制定了一套完整的工单申报流程，为每个客户提出的问题发起工单，然后在本地开启工单的代码分支，在分支里面针对性的加入埋点代码，然后推送代码给用户。</p><p>用户一端收集的信息经过数据脱敏后上报到我们的数据中心，我这边根据数据最终定位问题。</p><p>下面我挑一两个问题说吧。</p><blockquote><p>技术实现</p></blockquote><p>我们当时遇到的一个比较大的问题是HTTP1.1的效率问题，因为我们的客户有些浏览器是不支持HTTP2的，而首屏加载的资源量数量非常多，受我们架构的影响又很难合并它们，所以会遇到HTTP1.1的队头阻塞和头部压缩的问题。</p><p>针对队头阻塞，我使用了多域名的方式解决，这是常规手段，没多少可说的。而头部压缩这一块，我是借鉴了HTTP2的做法，在客户端和服务器分别建立静态表和动态表，把所有的自定义头部压缩成了一个，压缩比最高可以达到90，这是非常惊人的。</p><p>另外除了网络这一块，还遇到一个比较棘手的问题就是重复代码。客户那边很多代码是他们通过低码平台自动生成的，有些定制度比较高的客户可能生成了好几百个JS，这些JS文件中存在大量重复的代码，从而增加了整体的传输体积。</p><p>所以我开发了一套任务，它可以自动嗅探到多个JS文件中的重复代码，并把他们提取到一个公共JS中形成一个一个的函数，把差异化的地方自动提取为参数，然后自动修改原始JS文件的相应位置，把它们变成一个一个的函数调用。</p><p>这件事说起来简单，实际开发起来其实是非常复杂的，它涉及到抽象语法树分析、树结构对比从而发现重复和提取重复、hash运算和数据库存储等一系列的事情，因为这件事是在BFF层完成的，所以也是由我们前端处理的。</p><p>其他的优化还有很多，有些简单有些麻烦，但最棘手、我印象最深的就是上面两点。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理</title>
      <link href="/2023/06/20/liu-lan-qi-xuan-ran-yuan-li/"/>
      <url>/2023/06/20/liu-lan-qi-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是渲染"><a href="#什么是渲染" class="headerlink" title="什么是渲染"></a>什么是渲染</h3><p>html 经过一系列复杂运算得到像素点信息<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="image"></p><h3 id="渲染时间点"><a href="#渲染时间点" class="headerlink" title="渲染时间点"></a>渲染时间点</h3><p>当浏览器的网络进程收到 <code>HTML</code> 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4%E7%82%B9.jpg" alt="image"></p><h3 id="渲染步骤"><a href="#渲染步骤" class="headerlink" title="渲染步骤"></a>渲染步骤</h3><h3 id="1、解析-HTML-Parse-HTTML"><a href="#1、解析-HTML-Parse-HTTML" class="headerlink" title="1、解析 HTML-Parse HTTML"></a>1、解析 HTML-Parse HTTML</h3><p>解析过程中：</p><blockquote><p><strong><code>CSS</code> 不会阻塞 HTML 解析</strong>：因为下载和解析 CSS 的工作是在 <code>预解析线程</code> 中进行的。 为了提高效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 <code>HTML</code> 中的外部 <code>CSS</code> 和 <code>JS</code> 文件。<br>如果主线程解析到 <code>Link</code> 位置，此时外部<code> CSS</code> 文件还没有下载解析好，主线程不会等待，继续解析后续 HTML。</p></blockquote><blockquote><p><strong><code>JS</code> 会阻塞 HTML 解析</strong>：要等待下载并执行完后才会继续解析，因为 JS 代码的执行过程可能会修改当前的 <code>DOM</code> 树</p></blockquote><p>最终生成 <strong><code>DOM</code> 树</strong> 和 <strong><code>CSSOM</code> 树</strong>，</p><p><strong>样式表有哪些：</strong></p><pre><code>&lt;style&gt; // 内部样式表&lt;link ...&gt; // 外部样式表&lt;div style=""&gt; // 内联样式表（行内样式表）// 浏览器默认样式表</code></pre><p>这些样式均会包含在 <code>CSSOM</code> 树中。</p><h3 id="2、样式计算-Recalculate-Style"><a href="#2、样式计算-Recalculate-Style" class="headerlink" title="2、样式计算 - Recalculate Style"></a>2、样式计算 - Recalculate Style</h3><p>主线程会遍历 <code>DOM</code> 树，依次为树中的每个节点计算出它最终的样式(<code>Computed Style</code>)。<br>最终会得到一颗带有样式的 <code>DOM</code> 树。<br><strong><code>css</code> 属性值的计算过程</strong> 就发生在这里</p><ol><li> 确定声明值</li><li> 继承</li><li> 层叠</li><li> 使用默认值</li></ol><h3 id="3、布局-Layout"><a href="#3、布局-Layout" class="headerlink" title="3、布局 - Layout"></a>3、布局 - Layout</h3><p>布局阶段，会依次遍历 <code>DOM</code> 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对<strong>包含块</strong>的位置。</p><p><strong>DOM 树和 Layout 树不一定一一对应</strong></p><ul><li><code>display:none</code> 的节点没有几何信息，因此不会生成到布局树</li><li>伪元素。虽然 <code>DOM</code> 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。</li><li>匿名行盒、匿名块盒等</li></ul><p><strong>Layout 树规则</strong></p><ul><li>内容必须在行盒中</li><li>行盒和块盒不能相邻</li></ul><p><code>Layout</code> 树中不是 <code>DOM</code> 对象，是 <code>C++</code> 对象</p><h3 id="4、分层-Layer"><a href="#4、分层-Layer" class="headerlink" title="4、分层 - Layer"></a>4、分层 - Layer</h3><p>主线程会使用一套复杂的策略对整个布局树中进行分层。<br>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。<br>滚动条、堆叠上下文、<code>transform</code> 、<code>opacity</code> 等样式都会或多或少影响到分层结果，也可以通过 <code>will-change</code> 属性更大程度的影响分层结果。</p><h3 id="5、绘制-Paint"><a href="#5、绘制-Paint" class="headerlink" title="5、绘制 - Paint"></a>5、绘制 - Paint</h3><p>主线程会为每个分层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><p>渲染主线程的工作到此为止，剩余步骤交给其他线程完成.<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E7%BB%98%E5%88%B6.jpg" alt="image"></p><h3 id="6、分块-Tiling"><a href="#6、分块-Tiling" class="headerlink" title="6、分块 - Tiling"></a>6、分块 - Tiling</h3><p>完成绘制后，主线程会将每个图层的绘制信息提交到<strong>合成线程</strong>。<br>合成线程首先对每个图层进行<strong>分块</strong>，将其划分为更小的区域。<br>它会从<strong>线程池</strong>(用来分配可用的线程)中拿取多个线程来完成分块工作。<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E5%88%86%E5%9D%97.jpg" alt="image"></p><h3 id="7、光栅化-Raster"><a href="#7、光栅化-Raster" class="headerlink" title="7、光栅化 - Raster"></a>7、光栅化 - Raster</h3><p>分块后，合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p><code>GPU</code> 进程会开启多个线程来完成，并且<strong>优先处理靠近视口的块</strong>。</p><p>光栅化就是将每个块变成<strong>位图</strong><br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E5%85%89%E6%A0%85%E5%8C%96.jpg" alt="image"></p><h3 id="8、画-Draw"><a href="#8、画-Draw" class="headerlink" title="8、画 - Draw"></a>8、画 - Draw</h3><p>合成线程拿到每个层、每个块的位图后，会生成一个个指引(<code>quad</code>)信息</p><p>指引会标识出<strong>每个位图应该画到屏幕的哪个位置</strong>，以及会考虑到旋转、缩放等变形。</p><p><strong>变形</strong>发生在合成线程，只发生在最后这一步，与渲染主线程无关，这就是 <strong>transform</strong> <strong>效率高</strong>的原因</p><p>合成线程会把 <code>quad</code> 提交给 <code>GPU</code> 进程， 由 <code>GPU</code> 进程产生系统调用，提交给 <code>GPU</code> 硬件， 完成最终的屏幕成像。</p><p><strong>完整渲染过程</strong><br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.jpg" alt="image"></p><p><strong>这里做个扩展</strong>：<br>为什么合成线程不直接交给硬件(显卡)去画呢，为什么要通过 <code>GPU</code> 进程做一次中转？</p><blockquote><p>因为 <code>合成线程</code> 和 <code>渲染主线程</code> 是在 <code>渲染进程</code> 中的，而渲染进程是放在 <code>沙盒</code> 中的，没有<strong>系统调用</strong>的能力。沙盒中的东西与外界隔离，安全。就算浏览器访问页面时遭到攻击，也不会影响到计算机。</p></blockquote><p><strong>什么是 reflow</strong></p><p><code>reflow</code> 是当进行了会影响布局树的操作后，需要是重新计算布局树，引发 <code>layout</code>。</p><p>为了避免连续的多次操作导致树反复计算，浏览器会合并这些操作，当 <code>JS</code> 代码全部完成后再进行统一计算。所以，改动属性造成的 <code>reflow</code> 是<strong>异步</strong>完成的。</p><p>也同样因为如此，当 <code>JS</code> 读取布局属性时（例如 <code>dom.clientWith</code> )，就可能造成无法获取到最新的布局信息。</p><p>所以浏览器最终决定<strong>获取布局属性立即 reflow</strong>。</p><p><strong>什么是 repaint</strong></p><p><code>repaint</code> 是当改动了可见样式后，就需要重新计算，会引发 repaint.</p><p><code>reflow</code> 一定会引发 <code>repaint</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS继承</title>
      <link href="/2023/05/18/js-ji-cheng/"/>
      <url>/2023/05/18/js-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h1><p>对于使用过基于类的语言 (如 Java 或 C++) 的开发者们来说，JavaScript 实在是有些令人困惑 —— JavaScript 是动态的，本身不提供一个 <code>class</code> 的实现。即便是在 ES2015/ES6 中引入了 <code>class</code> 关键字，但那也只是语法糖，JavaScript 仍然是基于原型的。</p><p>当谈到继承时，JavaScript 只有一种结构：<strong>对象</strong>。每个实例对象（object）都有一个私有属性（称之为 __proto__）指向它的构造函数的原型对象（<strong>prototype</strong>）。该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个 <a href="https://mrw1108.github.io/2021/05/27/yuan-xing-yuan-xing-lian/">原型链</a> 中的最后一个环节。</p><p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p><p>尽管这种原型继承通常被认为是 JavaScript 的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。</p><blockquote><p>思路： 继承是什么 &gt;&gt; JS 继承依赖原型 &gt;&gt; 原型 &gt;&gt; 原型式继承 &gt;&gt; 原型链继承 &gt;&gt; 组合继承 &gt;&gt; 寄生式组合继承</p></blockquote><p><strong>继承</strong>，就是 A 的属性方法可以继承给 B，B 可以继续往下传。 同时，我们还希望</p><ul><li><strong>B 能够新增自己的属性和方法。</strong></li><li><strong>B 能够修改继承来的属性和方法，但不影响 A 也不干扰同代。</strong></li></ul><p>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>利用了原型上的数据能被共享这个特性，<strong>从外部看来，我们只是输入对象，然后就会产生一个新的拥有同样数据的对象</strong></p><p><strong>引用值问题：</strong> 如果 B 要修改 A 的属性，对于基本类型会在 B 上创建同名属性，而修改引用类型就会修改其原型</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> create <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> A <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span>  sayName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> B <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>B<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'18'</span><span class="token keyword">let</span> C <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span>C<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原形链继承"><a href="#原形链继承" class="headerlink" title="原形链继承"></a>原形链继承</h2><p>原型链继承的优势之一是可以更好地模拟<strong>类</strong>，从而更接近<strong>面向对象编程</strong>。</p><p>核心：将父类实例作为子类原型，将需要复用、共享的方法定义在父类原型上</p><p><strong>原型链继承的两个问题：</strong> 引用值问题、调用子类时无法对父类进行传参</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"父亲"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (该属性，强调私有)</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// -- 将需要复用、共享的方法定义在父类原型上</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>like<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 优点：共享了父类构造函数的say方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy2<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hello , hello , true</span><span class="token comment" spellcheck="true">// 缺点1：不能传参数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>name <span class="token operator">===</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父亲，父亲，true</span><span class="token comment" spellcheck="true">// 缺点2：共享引用值</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><ul><li>核心：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</li><li>优点：实例之间独立。</li><li>缺点：父类的方法不能复用（由于方法定义在构造函数中，每次创建实例都要创建一遍方法，方法应该要复用、共享）</li></ul><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (该属性，强调私有)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 实例引用属性 (该属性，强调复用，需要共享)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> like<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token string">"orange "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 优点1：可传参</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小红， 小明</span><span class="token comment" spellcheck="true">// 优点2：不共享父类构造函数的引用属性</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2] [1]</span><span class="token comment" spellcheck="true">// 缺点1：方法不能复用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false (说明，boy1和boy2 的say方法是独立，不是共享的)</span><span class="token comment" spellcheck="true">// 缺点2：不能继承父类原型上的方法</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>walk <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 在父类的原型对象上定义一个walk方法。</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我会走路"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>boy1<span class="token punctuation">.</span>walk<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined (说明实例，不能获得父类原型上的方法)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合是指<strong>原型链+借用构造函数</strong>。组合继承弥补了很多问题（如引用值问题），<strong>是 JavaScript 中使用最多的继承模式。</strong></p><p>缺点：会调用 2 次父类的构造方法。由于子类调用了父类的构造函数复制了父类的实例属性，又创建父类的实例作为子类的原型，会存在一份多余的父类实例属性。</p><p><strong>注意</strong>：<code>组合继承</code> 这种方式，要记得修复 <code>Child.prototype.constructor</code> 指向</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (该属性，强调私有)</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// --- 将需要复用、共享的方法定义在父类原型上</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> like<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> like<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心   第二次</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心   第一次</span><span class="token comment" spellcheck="true">// 注意：为啥要修复构造函数的指向？</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Parent 你会发现实例的构造函数居然是Parent。</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 优点1：可以传参数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>like<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小红，apple</span><span class="token comment" spellcheck="true">// 优点2：可复用父类原型上的方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 优点3：不共享父类的引用属性，如arr属性</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2] [1] 可以看出没有共享arr属性。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化：使用 <code>Child.prototype = Parent.prototype</code> 代替 <code>Child.prototype = new Parent()</code> ，只调用 1 次父类构造函数。子类原型和父类原型，实质上是同一个。</p><p><strong>上述优化的缺点：</strong> 修正构造函数的指向之后，父类实例的构造函数指向，同时也发生变化</p><p>因为通过原型来实现继承的，<code>Child.prototype</code> 的上面是没有 <code>constructor</code> 属性的, 所以会顺着原型链向上，修改的是 <code>Parent.prototype</code> 上面的 <code>constructor</code> 属性</p><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>使用 <code>Object.create</code> 优化了组合继承的缺点</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (该属性，强调私有)</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// --- 将需要复用、共享的方法定义在父类原型上</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> like<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> like<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心  通过创建中间对象，子类原型和父类原型，就会隔离开。不是同一个啦，有效避免了组合继承的缺点。</span><span class="token comment" spellcheck="true">// 修复构造函数指向</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小红"</span><span class="token punctuation">,</span> <span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">"小爸爸"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS API原理及实现</title>
      <link href="/2023/05/18/yi-xie-api-yuan-li-ji-shi-xian/"/>
      <url>/2023/05/18/yi-xie-api-yuan-li-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="x20-API"><a href="#x20-API" class="headerlink" title=" API"></a> API</h2><ul><li><a href="#-api"> API</a><ul><li><a href="#new">new</a></li><li><a href="#promisall">Promis.all</a></li><li><a href="#functionprototypeapply">Function.prototype.apply()</a></li><li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝</a></li></ul></li></ul><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ul><li>以构造器的 <code>prototype</code> 属性为原型，创建新对象</li><li><em>将 this 和调用参数传给构造器执行</em></li><li><em>如果构造器没有手动返回对象，则返回第一步的对象</em></li></ul><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取函数调用时的第一个参数，即为构造函数 fn</span>    <span class="token keyword">const</span> fn <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">' is not a constructor'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 以构造器的原型为原型，创建新对象</span>    <span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>    fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>    <span class="token keyword">return</span> obj<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Promis-all"><a href="#Promis-all" class="headerlink" title="Promis.all"></a><span id="Promis.all">Promis.all</span></h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myPromisAll</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> fulfilledCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> promises <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prom<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>prom<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>          result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>          fulfilledCount<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>fulfilledCount <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>promises<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a><span id="Function.prototype.apply()">Function.prototype.apply()</span></h3><pre class="line-numbers language-javascript"><code class="language-javascript">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>targetObject<span class="token punctuation">,</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 判断调用对象是否为函数</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"type error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 判断绑定的对象</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>targetObject <span class="token operator">===</span> undefined <span class="token operator">||</span> targetObject <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    targetObject <span class="token operator">=</span> window<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 因为 apply(2)也有值，但是数字不能添加属性，所以用 Object包装</span>  targetObject <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>targetObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 确保 targetFnKey唯一，防止覆盖掉原有的属性</span>  <span class="token keyword">const</span> targetFnkey <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  targetObject<span class="token punctuation">.</span>targetFnkey <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将执行结果保存并返回</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> targetObject<span class="token punctuation">.</span><span class="token function">targetFnkey</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除暂时增加的属性</span>  <span class="token keyword">delete</span> targetObject<span class="token punctuation">.</span>targetFnkey<span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><strong>这里有三点需要注意：</strong></p><ol><li> 用 <code>new obj.constructor ()</code> 构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承；</li><li> 用 <code>obj.hasOwnProperty(key)</code> ：判定自身是否含有这个属性，会忽略掉那些从原型链上继承到的属性，因为 for..in..也会遍历其原型链上的可枚举属性。</li><li> 上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 <code>arguments.callee</code>。</li></ol><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//方法一</span><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> newobj <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//判断对象的这条属性是否为对象</span>        newobj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//若是对象进行嵌套调用</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        newobj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> newobj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回深度克隆后的对象</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//方法二</span><span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保持继承链</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//不遍历其原型链上的属性</span>      <span class="token keyword">var</span> val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 使用arguments.callee解除与函数名的耦合</span>      newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> val <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">?</span> arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">:</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> newObj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型 &amp; 原型链</title>
      <link href="/2021/05/28/yuan-xing-yuan-xing-lian/"/>
      <url>/2021/05/28/yuan-xing-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>要先建立构造函数，构造函数的 prototype 属性会自动指向原型对象。<br>在创建实例后，可以修改 prototype 对象中的属性，但不可以重写整个原型（开始没有定义，再实例创建后给 prototype 添加属性</p><h2 id="构造函数、原型和实例的关系"><a href="#构造函数、原型和实例的关系" class="headerlink" title="构造函数、原型和实例的关系"></a>构造函数、原型和实例的关系</h2><ul><li>每个 <code>构造函数</code> 都有一个原型对象（原型 prototype）</li><li><code>原型</code>有一个 <code>constructor</code> 属性指回构造函数</li><li><code>实例</code>有一个内部指针 <code>[[Prototype]]</code> 指向原型</li><li>原型上的所有属性在实例间共享</li><li>实例上添加同名属性会遮蔽原型上的属性</li></ul><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.png?x-oss-process=style/format-size" alt="构造函数-原型-实例关系图"></p><p>如图，展示了 Person 构造函数、Person 的原型对象和 Person 现有的两个实例之间的关系。<code>Person.prototype</code>指向<code>原型对象</code>，<code>Person.prototype.constructor</code>指回<code>构造函数</code>。<br>原型对象中包含<code>constructor</code>属性和其他后来添加的属性。Person 的两个实例 person1 和 person2 都只有一个内部属性指回<code>Person.prototype</code>，而且两者与构造函数没有直接联系。</p><p><strong>实例的属性和方法</strong><br>虽然两个实例都没有属性和方法，但是它们<code>person1.sayName()</code>可以正常调用，这是由于对象属性查找机制，通过对象访问属性时，会按照这个属性的名称开始搜索，先搜索对象实例本身，如果有则返回对应的值，如果没有找到这个属性，则搜索会沿着<code>指针</code>进入原型对象，在原型对象上找到属性后，再返回对应的值。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>基本构想是：<code>实例</code> 指向 <code>原型</code>，而 <code>原型</code> 是另一个 <code>原型</code> 的 <code>实例</code> ，意味着这个<code>原型</code>的本身有一个内部指针指向另一个<code>原型</code>（继承的原型），相应的另一个<code>原型</code>也有一个指针指向另一个 <code>构造函数</code>（它自己的），这样<code>实例</code>和<code>原型</code>之间就构造了一条 <strong>原型链</strong>。<br><code>原型链</code> 扩展了原型搜索机制，读取实例上的属性时，先在实例上搜索，再搜索它继承的原型，再通过原型链 <code>继承</code> 后，搜索就可以继承向上，顺着 <code>原型链</code> 向上搜索其他的原型。<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg?x-oss-process=style/format-size" alt="原型链"></p><p>默认情况下，所有引用类型都继承<code>Object</code>,任何函数的默认原型都是一个<code>Object</code>的实例。<br>这意味着这个实例有一个内部指针指向这个<code>Object.prototype</code>，所以原型链的顶端还有<code>Object</code>, <code>Object.prototype</code> 是<code>null</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存 &amp; 本地存储</title>
      <link href="/2021/05/27/liu-lan-qi-huan-cun-ben-di-cun-chu/"/>
      <url>/2021/05/27/liu-lan-qi-huan-cun-ben-di-cun-chu/</url>
      
        <content type="html"><![CDATA[<p><code>缓存</code>可以说是<code>性能优化</code>中最简单高效的一种方式,可以减低网络延迟，减小带宽等。<br>对于一个数据请求来说，可以分为网络请求、后端处理、浏览器响应三步，而缓存可以优化第一步和第三步，比如直接使用缓存不需要再发送请求，或者发了请求但后端存储的数据与缓存一致，就没有必要再把数据传送过来了。</p><h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><ul><li>浏览器发送请求前，都会根据请求头判断是否命中<code>强缓存策略</code>，如果命中，直接获取缓存的资源，不会发送请求。</li><li>没有命中<code>强缓存策略</code>，浏览器会发送请求，根据请求头中的<code>Etag</code>和<code>last-modified</code>判断是否命中<code>协商缓存</code>，如果命中，直接获取缓存资源，否则获取服务器中的数据返回。</li></ul><p><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.jpg" alt="缓存过程"><br><strong>注：</strong> 图中仅表示判断的逻辑顺序，如果不带没些参数，可不进行判断</p><h3 id="Cache-Control-（缓存规则）"><a href="#Cache-Control-（缓存规则）" class="headerlink" title="Cache Control （缓存规则）"></a>Cache Control （缓存规则）</h3><p>服务端告诉浏览器此信息可不可以缓存，以什么样的策略进行缓存。</p><ul><li><code>private</code>:浏览器可以缓存</li><li><code>public</code>:浏览器和代理服务器可以缓存,因此我们中间层的服务节点，发现<code>cache-control</code>的值为 <code>private</code>时，就认可只有发起请求的浏览器能够缓存，作为代理服务节点是不能够缓存的。如为<code>public</code>时，代理服务器也可以缓存。</li><li><code>max-age</code> 单位 s 缓存到期时间</li><li><code>no-store</code> 不缓存请求的任何返回内容</li><li><code>no-cache</code> 会缓存请求返回的内容，在下次用缓存的内容时，需要向服务器验证一下，缓存到底能不能用</li></ul><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>如果资源没过期，直接获取缓存资源，过期了，再发送请求给服务器。<br>控制<code>强制缓存</code>的字段分别<code>是Expires</code>和<code>Cache-Control</code>，其中<code>Cache-Conctrol</code>的优先级比<code>Expires</code>高，若同时使用前者会覆盖掉后者。<br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/NetWork.png" alt="network"></p><p>灰色 <code>Status</code> 状态码 <code>200</code> 是<code>强缓存</code><br><code>from memory cache</code>: 内存中的缓存<br><code>from disk cache</code>: 硬盘中的缓存</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>没有命中强制缓存，浏览器携带缓存标识（<code>Etag</code>、<code>last-modified</code>)向服务端发起请求，判断是否过期，没过期使用缓存，status 为<code>304 not modified</code>。过期则返回服务器获取的数据，更新缓存。</p><p><code>200 OK </code> : <code>Size</code>是数据大小的是获取服务器数据,没有实用缓存</p><h3 id="为什么既有-last-modified-又有-Etag"><a href="#为什么既有-last-modified-又有-Etag" class="headerlink" title="为什么既有 last-modified 又有 Etag"></a>为什么既有 last-modified 又有 Etag</h3><ul><li>Etag 是文件的唯一标识，文件修改了标识就会变</li><li>last-modified 记录最后一次修改的时间</li><li>有些文件会周期性更改，但内容无变化（仅时间改变），这个时候我们不希望客服端认为这个文件被修改了。</li><li>某些文件修改的过于频繁，低于 s 级，不能精确获得更改时间等</li><li>所以 Etag 可以更精确的控制缓存</li></ul><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>用于存储客户端的会话信息，记录状态（因为 http 是无状态的)。要求服务器在响应 http 请求时，通过发送<code>Set-Cookie</code>HTTP 头部包含会话信息。浏览器会存储这些会话信息，并在之后的每个请求中都会通过 HTTP 头部 cookie 再将它们发送回服务器。<br><code>Cookie</code>同源窗口共享的，浏览器关闭后就会清空。</p><h4 id="Cookie-构成"><a href="#Cookie-构成" class="headerlink" title="Cookie 构成"></a>Cookie 构成</h4><p><code>name=value</code>;<code>name=value</code><br>一个 cookie 以<code>名/值对</code>形式存储，多个 cookie 之间以<code>分号</code>分割。<br>JavaScript 中只能用 BOM 的<code>document.cookie</code>属性来访问。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//document.cookie = "name=value"</span>document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">"id=1;username=xxx"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以自定义封装方法或者使用插件，如<code>vue-cookie</code>,<code>JQery-cookie</code>等</p><p><strong>创建 cookie</strong></p><pre><code>document.cookie="username=Jom"</code></pre><p>还可以为<code>cookie</code>添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：</p><pre><code>document.cookie="username=Jom; expires=Thu, 18 Dec 2021 12:00:00 GMT"</code></pre><p>可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面</p><pre><code>document.cookie="username=Jom; expires=Thu, 18 Dec 2021 12:00:00 GMT;path=/"</code></pre><p><strong>读取 cookie</strong></p><pre><code>var x = document.cookie;//结果将会以字符串形式返回 id=1;username=Jom</code></pre><p><strong>修改 cookie 与添加相同，会覆盖掉原来的</strong></p><p><strong>删除 cookie,只需要设置 expires 为以前的时间即可</strong></p><pre><code>document.cookie="username=;expires=Thu, 01 Jan 1970 00:00:00 GMT";</code></pre><h4 id="Cookie-限制"><a href="#Cookie-限制" class="headerlink" title="Cookie 限制"></a>Cookie 限制</h4><ul><li>与特定域绑定，只对认可的域接收，不被其他域访问</li><li>大小只有 4KB</li><li>所有<code>cookie</code>都会被作为请求头发送给服务器，所以若存储大量信息可能会影响浏览器请求的性能，所以尽可能只保留必要信息。</li><li>安全性：由于在 HTTP 请求中的<code>cookie</code>是明文传递的（HTTPS 不是），可能出现安全问题</li><li>所以为了更好的本地存储，使用<code>WebStorage</code>。<code>Cookie</code>作为客户端与服务器交互的通道，保持客户端状态。</li></ul><h1 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h1><p><code>WebStorage</code>提供两种 API，<code>localStorage</code>和<code>sessionStorage</code>。两者有共同的 API。</p><ul><li>length: 唯一的属性，只读，用来获取 storage 内的键值对数量</li><li>key：根据 index 获取 storage 的键名</li><li>getItem：根据 key 获取 storage 内的对应 value</li><li>setItem：为 storage 内添加键值对</li><li>removeItem：根据键名，删除键值对</li><li>clear：清空 storage 对象</li></ul><h3 id="localStorage-和-sessionStorage-区别"><a href="#localStorage-和-sessionStorage-区别" class="headerlink" title="localStorage 和 sessionStorage 区别"></a>localStorage 和 sessionStorage 区别</h3><ul><li><code>localStorage</code>本地永久存储，<code>sessionStorage</code>存储的数据只在会话期间有效，关闭浏览器则自动删除。</li><li><code>localStorage</code>支持同源窗口共享数据，<code>sessionStorage</code>不支持。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器缓存 </tag>
            
            <tag> cookie </tag>
            
            <tag> webStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/05/25/pai-xu-suan-fa/"/>
      <url>/2021/05/25/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><strong>目录</strong></p><ol><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li><li><a href="#%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F">合并排序</a></li><li><a href="#%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></li></ol><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>思路： 从数组开头开始，将未被排序的数组元素排序，然后迭代数组。该方法通过比较相邻元素然后置换元素完成排序。就是遍历数组，直到整个数组没有可交换元素为止。<br><strong>时间复杂度 O(n^2)，空间复杂度 O(1)</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//冒泡排序</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 相邻元素两两对比，元素交换，大的元素交换到后面</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思路：通过选择列表中最小值来与列表中第一个值进行对比交换，然后从第二个位置逐一对比，选择剩下列表中最小值来与第二个值交换位置。然后循环遍历列表并交换元素，直到最后一个元素为止。<br>所有情况均为<strong>时间复杂度 O(n^2),空间复杂度 O(1)</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//选择排序</span><span class="token keyword">function</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">var</span> minIndex<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//找到最小值下标</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思路：通过在列表的开头建一个排序的数组来实现整个排序，它以第一个元素开始排序数组，然后检查对比下一个元素，并将其向后交换到排序的数中，直到它处在排序的位置。循环迭代整个列表，将新产生的元素交换到排序部分，直到整个列表处于排序状态。该算法在平均和最坏的情况下<strong>时间复杂度 O(n^2)</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//插入排序</span><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">let</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token keyword">let</span> preIndex<span class="token punctuation">,</span> current<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//第一轮从array[1]开始向前比较</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//向后交换元素</span>      preIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将要排序的元素交换到正确排序位置</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序（常见）"><a href="#快速排序（常见）" class="headerlink" title="快速排序（常见）"></a>快速排序（常见）</h2><p>快速排序采用<a href="#%E5%88%86%E6%B2%BB%E6%B3%95"><strong>分治法</strong></a><br>思路：将原始数组选择一个基准值(下面的算法以中间数为基准)，将数组划分为两个子数组，其值大于或者小于基准值。然后两个子数组分别递归调用此快排算法排序，直到为空数组和单个元素数组的情况，得到结果。<br><strong>平均时间复杂度：O(nlogn)</strong><br><strong>空间复杂度 O(logn)</strong>(基准元素储存空间)</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//快速排序（以区间第一个数为基准）  例如：[2,6,3,8,1,9]</span><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> i<span class="token operator">=</span>l<span class="token punctuation">,</span> j<span class="token operator">=</span>r<span class="token punctuation">,</span> x<span class="token operator">=</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//以区间第一个数为基准(挖第一个坑）  x=a[0]=2 [_,6,3,8,1,9]</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从右边向左找第一个小于基准的数   arr[4]=1 （挖新坑） [_,6,3,8,_,9]</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//填上一个（第一个）坑  [1,6,3,8,_,9]</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//从左向右找第一个大于或者等于基准的数 （挖新坑）a[1]=6  [1,_,3,8,_,9]</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//填上一个坑 [1,_,3,8,6,9]</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//退出时，i等于j。将x填到最后这个坑中 [1,2,3,8,6,9]</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归左数组</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//递归右数组</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若以其他元素为基准，只需要最开始将基础元素与最左边元素交换即可</p><h2 id="合并排序（常见）"><a href="#合并排序（常见）" class="headerlink" title="合并排序（常见）"></a>合并排序（常见）</h2><p>思路：也采用了分而治之的递归方法来排序数组。利用递归将数组一分为二，直到数组里面只包含一个元素为止。单个元素的数组是自然序的，然后合并生成一个最终的排序数组。<br>合并排序是一种高效的排序方式<strong>时间复杂度：O(nlogn)</strong><br><img src="https://mrpaly.oss-cn-beijing.aliyuncs.com/Img/blogImg/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="image"><br><strong>具体的实现过程如下：</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="image"></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//合并排序（自上而下的递归）</span><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> array<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> left <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// slice(start,end)返回数组指定元素的新的数组</span>  <span class="token keyword">var</span> right <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//合并</span>  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//shift():删除数组第一个元素，并返回删除元素的值</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p><strong>分治法设计思想：</strong> 讲一个规模为 n 的问题分解为 k 个规模较小的相同子问题，递归得到子问题的解，合并得到原问题的解。<br><strong>用分治法一般具有以下特征</strong></p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决；</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构性质</strong></li><li>利用该问题分解出的子问题的解可以合并为该问题的解；</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</li></ul><p>如果各子问题不互相独立，会多做许多不必要的工作，产生重复解，所以这时一般用<strong>动态规划</strong>较好。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快排 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试知识概述</title>
      <link href="/2021/02/15/ruan-jian-ce-shi-zhi-shi-gai-shu/"/>
      <url>/2021/02/15/ruan-jian-ce-shi-zhi-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试知识概述"><a href="#软件测试知识概述" class="headerlink" title="软件测试知识概述"></a>软件测试知识概述</h1><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><ul><li>是提高软件产品质量的重要手段</li><li>开销占总成本的 30%-50%</li><li><strong>经济观点</strong> 以最小的代价获得最高的软件产品质量</li><li><strong>两面性：</strong> 正向思维：验证软件工作正常。逆向思维：假定软件有错误。为了发现尽可能多的错误，而不是证明程序无错</li><li>是<strong>SQA</strong>(软件质量保证)的重要手段之一，提供所需数据，作为质量评价的客观依据，他们都贯穿整个软件生命周期，SQA 是一项管理工作（对流程），测试是一项技术性工作（对产品）</li><li><strong>测试驱动开发思想：</strong> 测试在先，编码在后</li><li><strong>软件质量</strong> 满足用户规定的需求的程度</li><li><strong>软件缺陷</strong> 从产品内部看是软件产品开发或维护过程中所存在的错误、毛病等各种问题；从外部看是系统所需要实现的某种功能的失效或违背</li><li><strong>软件缺陷的变现行为</strong> 用户的功能没有完全实现</li><li><strong>测试用例</strong>是测试设计的产物</li><li><strong>被动测试</strong>方法中，软件产品运行在实际环境中，测试人员不干预产品运行，而是监控产品的运行，获取系统运行的数据，包括输入和输出数据。</li></ul><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>软件测试 V 模型贯穿着整个软件生命周期，避免了瀑布模型所带来的的误区–软件测试在代码完成之后进行。</p><blockquote><p>软件验证的 4 个层次：</p></blockquote><ol><li>需求验证 —&gt; 验收测试，客户需求的确认测试</li><li>系统架构设计的验证 —&gt; 系统非功能性测试</li><li>产品详细设计的验证 —&gt; 功能测试</li><li>代码的验证 —&gt; 单元测试和集成测试</li></ol><h3 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h3><ol><li>按测试阶段或层侧：（需求评审、设计评审）、单元测试、集成测试、系统测试、验收测试<ol><li><strong>单元测试</strong>：针对系统中最小的单元–类、函数、模块或组件。主要采用<strong>白盒测试</strong>，检查功能和编码错误</li><li><strong>集成测试</strong>：将模块按照设计要求组装起来进行测试。目标是发现单元之间的接口问题</li><li><strong>系统功能测试</strong>：一般在集成测试后进行，针对系统从用户角度进行功能验证（用户界面、操作、数据输入输出、存储）</li><li><strong>验收测试</strong>：验证软件的功能和性能及其他特性是否和用户的要求一致（同用户）</li></ol></li><li><strong>按方法：黑盒测试、白盒测试</strong></li><li>按目标/特性：强壮性测试、性能测试、适用性测试、安全性测试、可靠性测试</li><li>被测软件是否被执行：静态测试、动态测试</li></ol><p><strong>1.为什么软件需求规格说明书是软件缺陷存在最多的地方？</strong><br>（1）用户是非计算机专业人员，沟通存在困难，理解不一致<br>（2）完全靠想象描述系统，有些特性不够清楚<br>（3）用户需求不断变化，易出现前后文、上下文矛盾<br>（4）对规格说明书不够重视，投入的人力、时间不够<br>（5）没有在整个开发队伍中进行充分沟通</p><h3 id="软件测试的方法"><a href="#软件测试的方法" class="headerlink" title="软件测试的方法"></a>软件测试的方法</h3><ol><li><strong>黑盒测试和白盒测试</strong><ol><li><strong>黑盒测试（功能测试、数据驱动测试）</strong>：分析事物的输入输出以及周边条件<ol><li>特点：不关注内部结构 ，关注外部界面、输入输出、用户需求。验证产品每个功能是否能正常使用，评估软件质量。</li><li><strong>方法：</strong> 等价类划分、边界值分析（也可用于白盒测试）、错误推测（基于人的直觉和经验）</li><li>局限性： 不可能穷举测试、覆盖率难以测定或达到一定水平就难以提高</li></ol></li><li><strong>白盒测试（结构化测试、逻辑驱动测试）</strong>：分析事物内部结构和运行机制。<ol><li>基本原则：分支覆盖–&gt;逻辑覆盖</li><li>局限性：不能穷举出所有路径、不能检查出程序违反了设计规范（实现了用户不需要的功能）、不能检查程序因遗漏路径而出错、可能发现不了与数据相关的异常错误</li><li><strong>方法：</strong> 语句覆盖、判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、基本路径覆盖</li></ol></li><li></li></ol></li></ol><table><thead><tr><th></th><th>白盒测试方法</th><th>黑盒测试方法</th></tr></thead><tbody><tr><td>静态测试方法</td><td>对源程序代码的语法检查、扫描、评审等</td><td>对需求文档、需求规格说明书的审查活动</td></tr><tr><td>动态测试方法</td><td>在单元测试中，一边运行代码，一边对结果进行检查、验证和调试</td><td>在运行程序时，通过数据驱动对软件进行功能测试，从用户角度验证各项功能</td></tr></tbody></table><ol start="2"><li>基于直觉和经验的方法：错误推测</li><li><strong>基于输入域的方法</strong>（适合单变量，输入变量独立）：等价类划分、边界值分析<ol><li><strong>等价类划分</strong>： 有效等价类、无效等价类。建立等价类表–&gt;生成测试用例</li><li><strong>边界值分析</strong>：（通常作为等价类划分法的补充）使用等价类的边界作为测试条件，不仅要考虑输入条件，还要考虑输出条件</li><li><strong>常见的边界值</strong>：<ol><li>16bit 整数：32767 和 -32768</li><li>报表：第一行和最后一行</li><li>数组：第一个和最后一个</li><li>循环：第 0 次、第 1 次和倒数第 2 次、最后一次</li></ol></li></ol></li><li>基于组合及其优化的方法（适用于多种条件组合）：判定表法、因果图法、正交实验法<ol><li><strong>判定表法</strong>：<ol><li>定义：把所有输入的各种组合值以及对应输出值都罗列出来</li><li>适用条件：多因素输入和输出，根据某一个输入组合能直接判断出结果，只有 0、1 两个取值</li><li>组成：<ol><li>条件桩（列出问题的所有条件）</li><li>动作桩（问题规定可能采取的操作）</li><li>条件项（针对左侧条件的取值 0、1、—) <strong>“—“表示与之取值无关</strong></li><li>动作项（在条件项的各种取值下应采取的动作）、规则（某一个条件组合的取值及对应的操作）</li></ol></li><li>判定表简化：规则合并、规则包含</li></ol></li><li><strong>因果图法</strong>：找出因和果，画出因果图，通常和判定表结合使用<ol><li>介绍：Ci 表示原因，Ei 表示结果，各结点状态可表示为 0 或 1</li><li>原因与结果之间的关系：恒等、非~、或 ∨、与 ∧</li><li>约束关系：互斥 E、包含 I、唯一 O、要求 R、强制或屏蔽 M</li></ol></li></ol></li><li>基于逻辑覆盖的方法<ol><li>覆盖率：度量测试完整性。</li><li>逻辑覆盖<ol><li><strong>点覆盖</strong>：语句覆盖、块覆盖</li><li><strong>边覆盖</strong>：判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖</li></ol></li><li><strong>语句覆盖（最弱的）</strong>：程序中每个可执行语句至少执行一次</li><li><strong>块覆盖</strong>：语句覆盖的变体，指令块是函数体内部的一组语句，这组语句中不存在（会引起分支的）控制语句</li><li><strong>判定覆盖（分支覆盖）</strong>：每个判定的每种可能的结果（真或假）都至少执行一遍</li><li><strong>条件覆盖</strong>：每个判定中的每个条件的每种可能结果都至少执行一次</li><li><strong>判定-条件覆盖</strong>：每个判定中的每个条件的每种可能结果都至少执行一次，同时每个判定语句本身所有可能分支也至少执行一次</li><li><strong>条件组合覆盖</strong>：每个判定中所有可能的条件取值组合都至少执行一次</li><li><strong>基本路径覆盖</strong>：程序中所有可能的路径都至少执行一次</li><li>逻辑覆盖关系</li></ol></li></ol><pre><code>graph LR语句覆盖--&gt;判定覆盖判定覆盖--&gt;判定-条件覆盖条件覆盖--&gt;判定-条件覆盖判定-条件覆盖--&gt;条件组合覆盖判定覆盖--&gt;路径覆盖</code></pre><h3 id="软件测试过程和规范"><a href="#软件测试过程和规范" class="headerlink" title="软件测试过程和规范"></a>软件测试过程和规范</h3><ol><li><strong>传统的软件测试过程</strong>：需求评审、设计评审、单元和集成测试、系统测试、验收测试</li><li><strong>W 模型</strong>：测试过程和开发过程是同步关系，相互依赖</li><li><strong>TMap（测试管理方法）</strong>：是一种业务驱动的、基于风险策略的、结构化的测试方法体系。基本内容：计划、控制、基础设施、准备、说明、执行、完成</li><li><strong>敏捷测试特征</strong>：有鲜明的敏捷开发特征，测试驱动开发是核心，单元测试是基础；开发人员承担更多的测试，更依赖整个团队</li><li><strong>敏捷测试与传统测试的区别</strong><ol><li>强调整个团队对测试负责</li><li>强调持续集成，持续质量反馈</li><li>强调测试速度和适应性</li><li>不离用户需求，将验证和确认统一起来</li><li>清掉面对面沟通协作、强调团队责任</li><li>更关注产品本身</li><li>高度的自动化</li></ol></li><li><strong>敏捷测试 = 持续的质量反馈</strong></li><li><strong>基于风险的测试策略</strong>：评估测试的优先级，先做高优先的测试</li><li><strong>软件测试规范</strong>：对软件测试的流程过程化并对每一过程元素进行明确的界定，形成完整的规范体系</li><li><strong>软件测试规范的内容</strong>：角色、进入准则、输入项、活动、输出项、验证与确认、退出准则、度量</li></ol><h3 id="单元测试和集成测试"><a href="#单元测试和集成测试" class="headerlink" title="单元测试和集成测试"></a>单元测试和集成测试</h3><ul><li><strong>按阶段进行测试</strong>是一种基本的测试策略</li><li>单元测试是测试过程中的第一个阶段</li><li>集成测试确保每个单元能够正常结合起来构成系统</li><li>单元测试和集成测试可交替、同步进行</li><li>主要采用白盒测试方法，包括对代码的评审、静态分析和结合测试工具进行动态测试</li><li><strong>静态分析</strong>的查错和分析功能是其他方法不能替代的 -单元测试是为了及早发现错误，降低成本</li></ul><ol><li><p><strong>单元测试的任务</strong></p><ol><li>单元独立执行路径的测试</li><li>单元局部数据的测试</li><li>单元接口的测试</li><li>单元边界条件的测试</li><li>单元容错性的测试</li><li>内存分析</li></ol></li><li><p><strong>走查和审查对比</strong></p></li></ol><table><thead><tr><th></th><th>代码走查</th><th>会议审查</th></tr></thead><tbody><tr><td>准备</td><td>通过设计和编码</td><td>事先准备 Spec、程序设计文档、源代码清单、代码缺陷审查表等</td></tr><tr><td>形式</td><td>非正式会议</td><td>正是会议</td></tr><tr><td>参加人员</td><td>开发人员为主</td><td>项目组成员，包括测试人员</td></tr><tr><td>主要技术方法</td><td>无</td><td>缺陷检查表</td></tr><tr><td>生成文档</td><td>会议记录</td><td>静态分析错误报告</td></tr><tr><td>目标</td><td>代码标准规范无逻辑错误</td><td>代码标准规范无逻辑错误</td></tr></tbody></table><ol start="3"><li><strong>桩程序和驱动程序</strong><br>桩程序：替代被测模块工作过程中所调用的下层模块<br>驱动程序：替代被测模块的上级模块，可以调用被测模块</li><li><strong>集成测试</strong>：将通过测试的单元按照设计要求集成起来再进行测试，以检查这些单元接口是否存在问题</li><li><strong>非渐增式模式和渐增式模式</strong></li></ol><table><thead><tr><th>非渐增式</th><th>渐增式</th></tr></thead><tbody><tr><td>先分别测试每个模块，再把所有模块按设计要求结合成所要的程序。如大棒模式</td><td>把下一个要测试的模块同已经测试好的模块结合起来进行测试，测试完成以后下一个应该测试的模块结合进来测试，测试范围逐步增大</td></tr><tr><td>开销小</td><td>要编写的软件较多，工作量大</td></tr><tr><td>发现模块间错误时间晚</td><td>发现模块间错误时间早</td></tr><tr><td>发现错误，较难诊断</td><td>发生的错误往往和最近加进来的那个模块有关</td></tr><tr><td>测试不彻底</td><td>测试更彻底</td></tr><tr><td>可以并行测试</td><td>需要较多的机器时间</td></tr><tr><td>尽可能的缩短测试时间，使用最少的测试用例验证系统</td><td></td></tr></tbody></table><h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><ul><li><strong>系统测试</strong> 是将经过集成测试后的软件，作为计算机系统的一部分，与计算机硬件、某些支持软件、数据和平台等系统元素结合起来，在真是运行环境下对计算机系统进行一系列严格有效的测试</li><li><strong>系统测试目的</strong>：充分运行系统，验证整个系统是否满足功能和非功能性的质量需求</li><li><strong>回归测试</strong> 在程序有修改的情况下保证原有功能正常，不需要进行全面测试，而是根据修改的情况进行有效测试，保证改动不会带来新的验证错误。</li><li>在软件开发和测试的各个阶段都可能需要进行多次回归测试</li><li><strong>回归测试的目的</strong> 验证缺陷得到了正确的修复,同时对系统的变更,没有影响以前的功能</li><li><strong>回归测试的策略</strong>（要兼顾效率和有效性）： 再测试全部用例、基于风险选择测试、基于操作剖面选择测试、再测试修改的部分、更智能的选择方法</li><li><strong>常见的性能问题</strong> 资源耗尽、资源泄露、资源瓶颈</li><li><strong>系统性能指标</strong> 资源使用率、行为表现</li><li><strong>性能测试的过程</strong> 确定性能测试需求、开发测试脚本、建立性能测试负载模型、执行性能测试、提交性能测试报告</li><li><strong>压力测试（强度测试）</strong> 是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行软件，来测试系统的性能、可靠性、稳定性等</li><li><strong>容量测试的作用</strong> 了解软件系统的承载能力，确定软件系统还能保持主要功能正常运行的指标极限值。帮助用户经济地规划系统，优化系统和网略配置。</li><li><strong>安全性测试</strong> 检查系统对非法入侵的防范能力</li><li><strong>容错性测试</strong> 检查系统 的容错能力，检查检查软件在异常条件下自身是否具有防护性措施或某种灾难性恢复的手段</li><li><strong>软件的可靠性（软件质量的重要指标）</strong> 软件系统在规定的时间及规定的环境条件下，完成规定功能的能力</li><li><strong>可靠性测试、兼容性测试</strong></li></ul><h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><ul><li><strong>验收测试（交付测试）</strong> 在软件产品完成了系统功能和非功能测试之后、产品发布之前所进行的的软件测试活动。是软件测试的最后一个阶段。</li><li><strong>验收测试的目的</strong><ol><li>验证系统是否达到了用户需求规格说明书中要求</li><li>测试尽可能多的发现软件中留存的缺陷，从而为软件进一步改善提供帮助，并保证系统或产品最终被用户接收</li><li>验收测试主要包括易用性测试、安装测试、文档（如用户手册）测试等几个方面的内容</li></ol></li><li><strong>产品规格说明书验证</strong> 根据产品说明书，验证产品的每一项特性，并在验证结束时提交基于产品规格说明书的报告</li><li><strong>用户界面的 7 个因素</strong> 符合标椎和规范、直观性、一致性、灵活性、舒适性、正确性、实用性</li><li><strong>可用性测试</strong></li></ul><h3 id="测试自动化"><a href="#测试自动化" class="headerlink" title="测试自动化"></a>测试自动化</h3><table><thead><tr><th>手工测试</th><th>自动化测试</th></tr></thead><tbody><tr><td>发现缺陷率高</td><td>高效率（速度）</td></tr><tr><td>容易实施</td><td>高复用性</td></tr><tr><td>创造性、灵活性</td><td>覆盖率容易度量</td></tr><tr><td><strong>覆盖率量化困难</strong></td><td>准确、可靠</td></tr><tr><td><strong>重复测试效率低</strong></td><td>不知疲劳</td></tr><tr><td><strong>不一致性、可靠性低</strong></td><td>激励团队士气</td></tr><tr><td><strong>依赖人力资源</strong></td><td><strong>机械、难以发现缺陷</strong></td></tr><tr><td></td><td><strong>一次性投入大</strong></td></tr></tbody></table><ol><li><strong>测试自动化</strong> 是提高测试效率、覆盖率和可靠性的重要手段</li><li><strong>适用范围</strong><ol><li>在系统功能逻辑测试、验收测试、适用性测试、涉及物理交互性测试时，多采用手工测试（黑盒）方法</li><li>单元测试、集成测试、系统负载或性能、稳定性、可靠性测试等比较适合采用测试自动化</li><li>对那种不稳定软件的测试、开发周期很短的测试、一次性的软件等不适合测试自动化</li></ol></li><li><strong>自动比较技术</strong> 是测试自动化不可缺少的技术</li><li><strong>测试工具的使用是自动化测试的主要特征，也是自动化测试的主要手段</strong></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm,看这篇就够了</title>
      <link href="/2021/01/08/npm-kan-zhe-pian-jiu-gou-liao/"/>
      <url>/2021/01/08/npm-kan-zhe-pian-jiu-gou-liao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究 <code>npm</code> 组件发布，碰到一些相关问题，算是整理一下。</p><h3 id="涉及内容"><a href="#涉及内容" class="headerlink" title="涉及内容"></a>涉及内容</h3><ul><li>package.json 文件介绍</li><li>.npmrc 的作用及配置</li><li>公网 npm 组件发布</li></ul><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>package.json 定义了当前项目中 <code>npm包</code> 之间的依赖关系和项目的一些配置信息（项目名称，版本，描述，开发人，许可证 等等）。</p><p>当说到包管理器，就会遇到 <code>yarn</code> 和 <code>npm</code> 的选择性问题。我是喜欢用 <code>yarn</code><br>的，看看 <code>github</code> 上的开源项目，比如 <code>vue</code> 项目下就有 <code>yarn.lock</code> 文件，由此我猜测 <code>yarn</code> 可能更受欢迎一些，日常使用中我也是 <code>yarn</code> 用的比较多。</p><p>当我们 <code>npm install</code> 或 <code>yarn install</code> 会根据项目下的 <code>package.json</code> 解析依赖包之间的依赖关系然后从配置的 <code>npm registry</code> （ <code>.npmrc</code> 可以配置对应的 <code>registry</code>）地址中搜索并下载包。</p><p>我们可以在 <code>yarn.lock</code> 或 <code>package-lock.json</code> 看到包从哪里下载和依赖关系。</p><p>提交代码的时候排除 <code>node_modules</code> 目录，但是要提交 <code>yarn.lock</code> 或 <code>package-lock.json</code> ,用于锁定项目依赖包的版本。并且升级包的时候不要手动改 <code>package.json</code> 中的版本号，要使用命令 <code>yarn upgrade</code> 或 <code>npm upgrade </code> 升级。</p><p><code>npm init</code> 或 <code>yarn init</code> 可以生成 package.json。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"@mflyyou/npm-description"</span><span class="token punctuation">,</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.1.0"</span><span class="token punctuation">,</span>  <span class="token property">"private"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"张攀钦"</span><span class="token punctuation">,</span>  <span class="token property">"license"</span><span class="token operator">:</span> <span class="token string">"MIT"</span><span class="token punctuation">,</span>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span>  <span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"npm 搜索关键词"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"publishConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"registry"</span><span class="token operator">:</span> <span class="token string">"https://registry.npmjs.com/"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"repository"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"git"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://git.com/项目git地址"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"files"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"dist"</span><span class="token punctuation">,</span> <span class="token string">"src"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"bugs"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://localhost:8080//issues"</span><span class="token punctuation">,</span>    <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"bug@example.com"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"contributors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"zhangpanqin"</span><span class="token punctuation">,</span>      <span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"zhangpanqin@email.com"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"sh ./build/build.sh"</span><span class="token punctuation">,</span>    <span class="token property">"npm-version"</span><span class="token operator">:</span> <span class="token string">"npm -v"</span><span class="token punctuation">,</span>    <span class="token property">"serve"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service serve"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"vue"</span><span class="token operator">:</span> <span class="token string">"^2.5.21"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"@vue/cli-plugin-babel"</span><span class="token operator">:</span> <span class="token string">"^3.3.0"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"peerDependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="package-json-字段介绍"><a href="#package-json-字段介绍" class="headerlink" title="package.json 字段介绍"></a>package.json 字段介绍</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p><code>name</code> 字段作为项目的名称。 比如 vue 中的一个组件 <code>@vue/cli-plugin-babel</code> ，前面这个 <code>@vue</code> 其实就当前包的 scope ，既命名空间。我们可以根据 <code>scope</code> 配置一些私有包 <code>registry</code>，从而达到一些包来源于特定的地址。</p><pre class="line-numbers language-txt"><code class="language-txt">registry=https://registry.npm.taobao.org/@pay-plugin:registry=https://npm.udolphin.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> version <span class="token punctuation">[</span><span class="token operator">&lt;</span>newversion<span class="token operator">></span> <span class="token operator">|</span> major <span class="token operator">|</span> minor <span class="token operator">|</span> patch <span class="token operator">|</span> premajor <span class="token operator">|</span> preminor <span class="token operator">|</span> prepatch <span class="token operator">|</span> prerelease <span class="token punctuation">[</span>--preid<span class="token operator">=</span><span class="token operator">&lt;</span>prerelease-id<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">|</span> from-git<span class="token punctuation">]</span><span class="token string">'npm [-v | --version]'</span> to print <span class="token function">npm</span> version<span class="token string">'npm view &lt;pkg> version'</span> to view a package<span class="token string">'s published version'</span><span class="token function">npm</span> ls' to inspect current package/dependency versions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“version”: “0.1.0”, 对应 <code>major-minor-patch</code></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 更新 major 的位置，其余位置为 0</span><span class="token function">npm</span> version major<span class="token comment" spellcheck="true"># 更新 minor 的位置，major 不变，其余位置为 0</span><span class="token function">npm</span> version minor<span class="token comment" spellcheck="true"># 更新 patch 的位置，其余位置不变</span><span class="token function">npm</span> version patch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>major 对应一次大的迭代，比如 vue 3.0 ts 重新，添加新的功能，更新 major 版本号</li><li>minor 对应小版本迭代，发生兼容旧版 API 的修改或功能添加时，更新 minor 版本号</li><li>patch 对应修订版本号，一般针对 bug 修复时，修改 patch 的版本号</li></ul><p>当你的项目需要发布的时候，version 一定要和以前的不一样，否则发布不成功。</p><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>标识当前包是否私有，为 <code>true</code> 时包不能发布。</p><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>默认 index.js。指定 import 或 require 的时候加载的 js。</p><h4 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h4><p>描述当前项目的关键字，用于检索当前插件。</p><h4 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"publishConfig"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"registry"</span><span class="token punctuation">:</span> <span class="token string">"https://registry.npmjs.com/"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有的时候呢我们在 <code>.npmrc</code> 配置了别的 <code>registry</code> ，比如淘宝镜像。我安装依赖包的时候呢，想从淘宝镜像安装。发布插件的时候想发布到官网上。就可以在 <code>publishConfig</code> 中配置了。</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4><p>指定发布的依赖包，包含的文件，默认会忽略一些文件。也可以根目录下创建 .npmignore 忽略一些文件。</p><p><img src="http://oss.mflyyou.cn/blog/20200304021818.png"></p><h4 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h4><p>配置一些执行脚本。比如说 <code>npm run dev</code> 就是运行 <code>sh ./build/build.sh</code>。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 运行 shell 脚本</span>    <span class="token string">"dev"</span><span class="token punctuation">:</span> <span class="token string">"sh ./build/build.sh"</span><span class="token punctuation">,</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"npm -v"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// build 成功之后会执行 publish</span>    <span class="token string">"pub"</span><span class="token punctuation">:</span> <span class="token string">"npm run build &amp;&amp; npm publish"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h4><p>项目的开发依赖。key 为模块名称，value 为版本范围。项目打包时会将这里的依赖打包进去。</p><p><a href="https://github.com/wanguzhang/fly-npm">fly-npm 地址</a></p><p>fly-npm 和 fly-use-npm 已发布。</p><p>注意，这里也有个坑。比如我有两个插件 fly-npm，fly-use-npm，fly-use-npm 中 dependencies 中依赖 fly-npm。我在 my-vue 项目开发的时候引入 fly-use-npm。我是可以直接 <code>import fly-use-npm</code> 项目可以正常运行。但是当你 <code>import fly-npm</code> 项目解析依赖会报错。因为只有在当前项目中 dependencies 引入的依赖才可以被 import。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"clickTest"</span><span class="token operator">></span>            测试        <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token comment" spellcheck="true">// fly-npm 只有在当前 my-vue 项目 dependencies 引入才可以被 import</span><span class="token comment" spellcheck="true">//import flyNpm from 'fly-npm';</span><span class="token keyword">import</span> flyUseNpm <span class="token keyword">from</span> <span class="token string">'fly-use-npm'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'TestPlugin'</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">clickTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">flyUseNpm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h4><p>为开发依赖，打包的时候不会打包进去。比如我们使用的 <code>babel</code> <code>webpak</code> 等相关的插件，打包的时候，并不会被打包进去。</p><h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><p>在将这个之前，我们先来了解 npm 的树形依赖是什么意思。</p><p>我创建一个 vue 项目 my-vue 依赖 fly-use-npm(它依赖 fly-npm 1.0.0)，fly-npm(2.0.0)，在我们项目中可以看到。</p><p>当 <code>my-vue</code> 没有引入 <code>fly-npm 2.0.0</code> 的时候，<code>my-vue/node_modules/fly-npm</code> 为 1.0.0。</p><p><img src="http://oss.mflyyou.cn/blog/20200304021831.png"></p><p>当我们引入 <code>fly-npm 2.0.0</code> 的时候，依赖关系图如上图，这就是树形依赖。</p><p>下面是测试引入 <code>fly-npm 2.0.0</code> 之后的变化。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"clickTest"</span><span class="token operator">></span>            测试        <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> flyUseNpm <span class="token keyword">from</span> <span class="token string">'fly-use-npm'</span><span class="token punctuation">;</span><span class="token keyword">import</span> flyNpm <span class="token keyword">from</span> <span class="token string">'fly-npm'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'TestPlugin'</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">clickTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打印 2.0.0</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fly-npm'</span><span class="token punctuation">,</span> flyNpm<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用的是 1.0.0</span>            <span class="token function">flyUseNpm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面我们可以看到，一个项目存在了两份 fly-npm 的包。这样打包的体积相应也会增大。为了解决这个问题，引入了 <code>peerDependencies</code> 。</p><p>创建 vue 项目 my-vue，依赖 fly-use-npm(4.0.0,其 <code>peerDependencies</code> 是 fly-npm 1.0.0 )。</p><p><code>peerDependencies</code> 添加的依赖包，不会（测试的 yarn 1.22.0，npm 6.13.7）自动安装的。</p><p>当我在 my-vue 项目 <code>yarn install</code> 的时候，由于没有引入 <code>fly-npm</code> 会报错。</p><p>当我在项目中引入 <code>fly-npm 2.0.0</code> 安装会在当前项目下，出现警告信息。</p><blockquote><p>warning “ &gt; <a href="mailto:fly-use-npm@4.0.0">fly-use-npm@4.0.0</a>“ has incorrect peer dependency “<a href="mailto:fly-npm@1.0.0">fly-npm@1.0.0</a>”。</p></blockquote><p>当你开发一个组件，依赖特定包的版本就需要这样处理。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// fly-use-npm</span><span class="token keyword">import</span> flyNpm <span class="token keyword">from</span> <span class="token string">"fly-npm"</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"引用的 fly-npm 版本为:"</span><span class="token punctuation">,</span> flyNpm<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>flyNpm<span class="token punctuation">.</span>version <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"版本大于 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> obj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>算是场景模拟，fly-npm 最新包是 2.0.0，这算是一个重大版本升级，可能存在不兼容 1.0.0 的东西。所以我在 fly-use-npm 推荐使用（peerDependencies）1.0.0。当我在实际用的时候呢，引入 fly-npm 2.0.0 ,发现某个功能依赖 fly-npm 2.0.0 报错了，就需要想到是不是依赖包不兼容的问题了。</p><p>但是同时你还想用 fly-npm 2.0.0 的功能，那你只能去提交一个 pr 兼容 fly-npm 或者 fly-use-npm 。</p><p>这种情况很少会遇到，一般版本升级都会兼容以前的功能的，也不用太在意这样的问题。</p><p>一般我们很少会遇到这种问题。<code>github</code> 上流行的库也很少会用到 <code>peerDependencies</code>。</p><h2 id="npmrc"><a href="#npmrc" class="headerlink" title=".npmrc"></a>.npmrc</h2><p><code>package.json</code> 中的依赖包从哪里安装呢？.npmrc 可以配置依赖包从哪里安装，也可以配置 npm 的一些别的配置。</p><h3 id="npmrc-配置文件优先级"><a href="#npmrc-配置文件优先级" class="headerlink" title=".npmrc 配置文件优先级"></a>.npmrc 配置文件优先级</h3><ul><li>项目配置文件: <code>/project/.npmrc</code></li><li>用户配置文件：<code>~/.npmrc</code></li><li>全局配置文件：<code>/usr/local/etc/npmrc</code></li><li>npm 内置配置文件 <code>/path/to/npm/npmrc</code></li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 获取 .npmrc 用户配置文件路径</span><span class="token function">npm</span> config get userconfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>项目下 .npmrc 文件的优先级最高，可以每个项目配置不同的镜像，项目之间的配置互不影响。我们也可以指定特殊的命名空间（scope）的来源。</p><p>以<code>@thingjs-plugin</code> 开头的包从 <code>registry=https://npm.udolphin.com</code> 这里下载，其余全去淘宝镜像下载。</p><pre class="line-numbers language-txt"><code class="language-txt">registry=https://registry.npm.taobao.org/@thingjs-plugin:registry=https://npm.udolphin.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-txt"><code class="language-txt">npm config set <key> <value> [-g|--global]  //给配置参数key设置值为value；npm config get <key>                        //获取配置参数key的值；npm config delete <key>  [-g|--global]      //删除置参数key及其值；npm config list [-l]                        //显示npm的所有配置参数的信息；npm config edit                             //编辑用户配置文件npm get <key>                               //获取配置参数 key 生效的值；npm set <key> <value> [-g|--global]         //给配置参数key设置值为value；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有加 -g 配置的是用户配置文件</p><p>-g 会配置到全局配置文件</p><h2 id="npm-组件发布流程"><a href="#npm-组件发布流程" class="headerlink" title="npm 组件发布流程"></a>npm 组件发布流程</h2><ul><li>去 npm 官网申请账号</li><li>添加账号到你电脑</li><li>开发你的组件，使用 webpack,babel 处理</li><li>npm 发布你的包</li></ul><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p><a href="https://www.npmjs.com/">官网</a>申请一个账号，用于登录和发布组件。</p><p>在项目的根路径下创建 <code>.npmrc</code> 配置文件，添加如下内容。</p><pre class="line-numbers language-txt"><code class="language-txt"># 安装包的时候，配置阿里镜像registry = https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 <code>package.json</code> 中配置发布源。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"publishConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"registry"</span><span class="token operator">:</span> <span class="token string">"https://registry.npmjs.com/"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样下载依赖包会从淘宝镜像下载，发布依赖包会发布到 npm 官网去。</p><h3 id="添加账号到你电脑"><a href="#添加账号到你电脑" class="headerlink" title="添加账号到你电脑"></a>添加账号到你电脑</h3><p><a href="https://docs.npmjs.com/cli/adduser">添加账号命令官网说明 npm adduser</a></p><pre><code># npm adduser [--registry=url] [--scope=@orgname] [--always-auth] [--auth-type=legacy]npm adduser  --registry=https://registry.npmjs.com/</code></pre><p>运行上述命令，.npmrc 用户配置文件生成一下内容</p><pre><code>registry=https://registry.npmjs.com///registry.npmjs.com/:_authToken=xxx</code></pre><h3 id="开发你的组件，使用-webpack-babel-处理"><a href="#开发你的组件，使用-webpack-babel-处理" class="headerlink" title="开发你的组件，使用 webpack,babel 处理"></a>开发你的组件，使用 webpack,babel 处理</h3><p>由于 webpack,babel 配置比较麻烦，这里使用 <a href="https://cli.vuejs.org/zh/">vue-cli</a> 脚手架进行开发</p><h4 id="package-json-1"><a href="#package-json-1" class="headerlink" title="package.json"></a>package.json</h4><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"@thingjs-ad/thingjs-app"</span><span class="token punctuation">,</span>  <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.1.1"</span><span class="token punctuation">,</span>  <span class="token property">"private"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"serve"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service serve"</span><span class="token punctuation">,</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service build --target lib --name thingjs-app ./src/index.js"</span><span class="token punctuation">,</span>    <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service lint"</span><span class="token punctuation">,</span>    <span class="token property">"pub"</span><span class="token operator">:</span> <span class="token string">"npm run build &amp;&amp; npm publish --access=public"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"dist/thingjs-app.umd.min.js"</span><span class="token punctuation">,</span>  <span class="token property">"files"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src"</span><span class="token punctuation">,</span> <span class="token string">"dist"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"@vue/cli-plugin-babel"</span><span class="token operator">:</span> <span class="token string">"^4.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"@vue/cli-plugin-eslint"</span><span class="token operator">:</span> <span class="token string">"^4.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"@vue/cli-service"</span><span class="token operator">:</span> <span class="token string">"^4.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"babel-eslint"</span><span class="token operator">:</span> <span class="token string">"^10.0.3"</span><span class="token punctuation">,</span>    <span class="token property">"eslint"</span><span class="token operator">:</span> <span class="token string">"^6.7.2"</span><span class="token punctuation">,</span>    <span class="token property">"eslint-plugin-vue"</span><span class="token operator">:</span> <span class="token string">"^6.1.2"</span><span class="token punctuation">,</span>    <span class="token property">"vue-template-compiler"</span><span class="token operator">:</span> <span class="token string">"^2.6.11"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"eslintConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"root"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"env"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"node"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"plugin:vue/essential"</span><span class="token punctuation">,</span> <span class="token string">"eslint:recommended"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"parserOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"parser"</span><span class="token operator">:</span> <span class="token string">"babel-eslint"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"browserslist"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"> 1%"</span><span class="token punctuation">,</span> <span class="token string">"last 2 versions"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件内容"><a href="#组件内容" class="headerlink" title="组件内容"></a>组件内容</h4><p><img src="http://oss.mflyyou.cn/blog/20200304021841.png"></p><ul><li>AA.vue</li></ul><pre><code>&lt;template&gt;     &lt;div&gt;         AA 组件     &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name:'AA'};&lt;/script&gt;</code></pre><ul><li>index.js</li></ul><pre><code>import AA from './components/AA.vue';const components = [AA];// 当调用 Vue.use,实际会调用这个 install 方法。Vue.component 注册全局组件。const install = function (Vue) {    components.forEach(component =&gt; {        Vue.component(component.name, component);    });};if (typeof window !== 'undefined' &amp;&amp; window.Vue) {    install(window.Vue);}export default {    version: '1.0.0',    install,    AA}</code></pre><h3 id="发布组件"><a href="#发布组件" class="headerlink" title="发布组件"></a>发布组件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> publish --access<span class="token operator">=</span>public<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo,搭建个人博客</title>
      <link href="/2021/01/08/hexo-da-jian-ge-ren-bo-ke/"/>
      <url>/2021/01/08/hexo-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用 hexo 和腾讯云搭建的个人博客<br> hexo 选用了开源主题 <code>hexo-theme-matery</code>,<br>做了些许修改。</p><p>博客的具体效果请观摩 <a href="http://paly.bwmgd.club/">.paly 的博客</a></p><h3 id="本文概要"><a href="#本文概要" class="headerlink" title="本文概要"></a>本文概要</h3><ul><li>hexo 使用，及怎么去改主题的模板</li><li>腾讯云服务器，搭建 nginx/Apache</li><li>git 配置，一键上传资源到网站根目录<!--- 百度、谷歌 seo 优化，让你的网站可以被搜索到--><!--- 阿里 oss 作为图片服务器--><!--- CDN 加速提高首屏渲染--><!--- 目录下，将所需静态资源上传到 oss--></li></ul><h2 id="hexo-使用"><a href="#hexo-使用" class="headerlink" title="hexo 使用"></a>hexo 使用</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 清除构建生成的 public 目录</span>hexo clean<span class="token comment" spellcheck="true"># 生成当前目录资源</span>hexo g<span class="token comment" spellcheck="true"># 部署到远程</span>hexo d<span class="token comment" spellcheck="true"># 本地预览</span>hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h3><pre class="line-numbers language-bash"><code class="language-bash">hexo new post <span class="token operator">&lt;</span>title<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text"><code class="language-text">或者将md文件放进/source/_posts文件夹下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-json"><code class="language-json">---title<span class="token operator">:</span> typora-vue-theme主题介绍date<span class="token operator">:</span> <span class="token number">2021</span>-<span class="token number">01</span>-<span class="token number">08</span> <span class="token number">09</span><span class="token operator">:</span><span class="token number">25</span><span class="token operator">:</span><span class="token number">00</span>author<span class="token operator">:</span> 赵奇img<span class="token operator">:</span> /source/images/xxx.jpgtop<span class="token operator">:</span> <span class="token boolean">true</span>cover<span class="token operator">:</span> <span class="token boolean">true</span>coverImg<span class="token operator">:</span> /images/<span class="token number">1</span>.jpgpassword<span class="token operator">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc<span class="token operator">:</span> <span class="token boolean">false</span>mathjax<span class="token operator">:</span> <span class="token boolean">false</span>summary<span class="token operator">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories<span class="token operator">:</span> Markdowntags<span class="token operator">:</span>  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文档 md 文件最前面的这些内容就会被利用生成 <code>标签</code> <code>分类</code> <code>归档</code> 内容。<br><code>root/_config.yml</code> 为 hexo 的配置文件。<br><code>root/themes/_config.yml</code> 为主题配置文件。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h2><p>具体搭建请参考此教程 <a href="http://mflyyou.cn/2020/03/06/hexo-da-jian-ge-ren-bo-ke/">hexo,搭建个人博客</a></p><!--## 部署--><!--执行脚本 deploy.sh 会将构建好的 public 下的资源复制到远程服务器上--><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感觉开源的 hexo 主题 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></p><p>感谢<a href="https://github.com/godweiyang/hexo-matery-modified">hexo-matery-modified</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> cdn </tag>
            
            <tag> oss </tag>
            
            <tag> git </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛概知识概述</title>
      <link href="/2021/01/08/mao-gai-zhi-shi-gai-shu/"/>
      <url>/2021/01/08/mao-gai-zhi-shi-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="毛概知识概述"><a href="#毛概知识概述" class="headerlink" title="毛概知识概述"></a>毛概知识概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>马克思主义:</strong> 是关于自然界、人类社会、人类思维发展的一般规律的理论体系</p><p><strong>马克思主义中国化：</strong></p><blockquote><p><strong>内容</strong></p><ul><li>马克思主义中国化就是把马克思主义基本原理同中国具体实际和时代特征结合起来，运用马克&gt;思主义的立场、观点、方法研究和解决中国革命、建设、改革中的问题；</li><li>就是总结提炼中国革命、改革建设的实践经验，从而认识和掌握客观规律，为马克思主义增添新的内容；</li><li>运用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色、中国风格、中国气派的马克思主义</li></ul></blockquote><blockquote><p><strong>重要性：</strong> 历史和现实反复证明，马克思主义只有中国化才能在中国大地上闪耀真理光芒 ，也只有实现中国化才能救中国、发展中国、发展社会主义</p></blockquote><blockquote><p><strong>两次飞跃</strong> （毛泽东思想和中国特色社会主义理论主义体系）</p><ul><li>新民主主义时期，形成毛泽东思想</li><li>社会主义进入改革开放时期，形成了包括邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义理论体系。</li></ul></blockquote><p><strong>一些重要的事件和人物</strong></p><ul><li>遵义会议：认识了马克思主义的重要地位</li><li>延安整风（1942-1945）：马克思主义中国化思想成为全党共识</li><li>党的二大：提出了党在民主革命时期的纲领</li><li>党的三大：提出了建立了国共统一战线的思想（忽视领导权问题）</li><li>党的四大：第一次提出无产阶级领导权和农民同盟军的思想</li><li>党的十二大： 最终确定毛泽东思想</li><li>党的十四大：把建设社会主义市场经济确立为经济体制改革的目标</li><li>1945 陈独秀 建立新青年杂志</li><li>1917 俄国十月革命成功 开辟无产阶级社会主义新时代</li><li>1919 和平会议 ++五四运动的开始++，拒绝在合约上签字（工人阶级力量）<br>促进了马克思主义和社会会主义</li></ul><h2 id="第一章-毛泽东思想"><a href="#第一章-毛泽东思想" class="headerlink" title="第一章 毛泽东思想"></a>第一章 毛泽东思想</h2><p><strong>三大作风</strong> 理论和实践相结合的作风、和人民群众紧密结合在一起的作风、以及自我批评的作风</p><p><strong>活的灵魂</strong> 实事求是、群众路线、独立自主</p><p><strong>形成和发展过程</strong> 在土地革命战争时期形成，在抗日战争时期走向成熟，并在解放战争时期和新中国成立后继续发展</p><p><strong>1.毛泽东思想形成和发展的社会历史条件是什么？</strong><br>（1）20 世纪前中期世界和中国政局的变动，是毛泽东思想产生和形成的时代背景。<br>（2）毛泽东思想的产生和形成，是近现代中国社会和革命运动发展的客观需要和历史产物。<br>（3）新的社会生产力的增长和工人运动的发展，为毛泽东思想的产生和形成提供了物质基础。<br>（4）新文化运动的兴起和马克思列宁主义的传人与传播，为毛泽东思想的产生和形成准备了思想理论条件。<br>（5）中国共产党领导的人民革命，是毛泽东思想产生和形成的实践基础。</p><p><strong>2.如何把握毛泽东思想的主要内容和活的灵魂？</strong></p><blockquote><p><strong>主要内容</strong>：① 关于新民主主义革命；② 关于社会主义革命和社会主义建设；③ 关于革命军队的建设和军事战略；④ 关于政策和策略；⑤ 关于思想政治工作和文化工作；⑥ 关于党的建设。<br><strong>毛泽东思想活的灵魂</strong>：是贯穿于毛泽东思想各个组成部分的立场、观点和方法，它们有三个基本方面，即<strong><em>实事求是、群众路线、独立自主</em></strong>。其中，实事求是是毛泽东思想的精髓，群众路线是中国共产党的根本路线，独立自主是中国革命和建设的基本立足点。<br>毛泽东思想的独创性理论和活的灵魂，构成毛泽东思想的科学体系。这一体系具有科学性、独创性、完整性等特点。</p></blockquote><p><strong>3.毛泽东思想科学概念的涵义是什么?（历史地位？）</strong><br>是马克思主义中国化的第一个重大理论成果；是中国革命和建设的科学指南；是中国共产党和人民的宝贵精神财富；是党的指导思想。毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶，这就是毛泽东思想的科学涵义。</p><h2 id="第二章-新民主主义革命理论"><a href="#第二章-新民主主义革命理论" class="headerlink" title="第二章 新民主主义革命理论"></a>第二章 新民主主义革命理论</h2><ul><li><strong>近代中国基本国情</strong> 半殖民半封建社会</li><li>半殖民地化 是政治上的</li><li><strong>革命基本动力</strong> 无产阶级</li><li><strong>革命基本问题</strong> 农民问题</li><li><strong>革命中心问题</strong> 无产阶级领导权</li><li><strong>中国革命战争实质</strong> 农民战争</li><li><strong>城市小资产阶级</strong> 不是剥削者，不属于资产阶级</li><li><strong>民族资产阶级</strong> 中国革命动力之一。<strong>两面性：</strong> 革命性、软弱性（新民主主义革命时期）</li><li><strong>一次革命论</strong> 只看到两者（新民主主义革命和社会主义革命）联系，没看到区别</li><li><strong>二次革命论</strong> 只看到两者区别，没看到联系</li><li><strong>新民主主义革命的总路线</strong> 1948 年提出，内容是无产阶级领导的、人民大众的，反对帝国主义、封建主义和官僚资本主义的革命</li><li><strong>三大法宝</strong> 统一战线、武装斗争、党的建设</li></ul><p><strong>新民主主义基本纲领</strong></p><blockquote><p><strong>政治纲领</strong> 国体（内容）–各革命阶级联合专政，政体（形式）–民主集中制的人民代表大会制度，这就是新民主主义政治<br><strong>经济纲领</strong> 基本内容为无产阶级领导的人民大众反帝反封建文化<br><strong>文化纲领</strong></p></blockquote><p><strong>新民主主义革命道路的内容和意义</strong></p><blockquote><p><strong>内容</strong>： 走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系。<br><strong>三者关系：</strong> 土地革命史民主革命的基本的内容；武装斗争是主要形式，是土地革命的保证；农村革命根据地是进行武装斗争和开展土地革命的依托。实现三者密切结合和有机统一。</p></blockquote><h2 id="第三章-社会主义改造理论"><a href="#第三章-社会主义改造理论" class="headerlink" title="第三章 社会主义改造理论"></a>第三章 社会主义改造理论</h2><ul><li><strong>新民主主义社会是一个过渡性的社会</strong> 不是独立社会形态，属于社会主义体系；经济成分：个体经济、资本主义经济、社会主义经济</li><li><strong>一化三改</strong> “一化”社会主义工业化，“三改”个体农业、手工业、资本主义工商业的社会主义改造</li><li><strong>四马分肥</strong> 企业的利润，按国家所得税、企业公积金、工人福利费、资方红利这四个方面进行分配</li><li><strong>三大改造</strong> 农业、手工业、资本主义工商业</li><li><strong>社会主义制度在中国确立</strong> 1956 年底，三大改造完成（起点）</li></ul><p><strong>1.怎样理解党在过渡时期的总路线？</strong><br>是以“一化三改”为核心的总路线。一是逐步实现社会主义工业化，这是总线路的主体；二是实现对农业、手工业和资本主义工商业的改造。这两方面相互联系、相互促进、相互制约，是一条社会会主义建设和社会主义改造同时并举的路线。是根据马克思列宁主义基本原理，结合我国具体实际，创造性地开辟了一条适合中国特色社会会主义改造道路，成功完成了生产资料私有制的社会主义改造，实现中国历史上最深刻最伟大的社会变革，是毛泽东思想的重要思想，积累了宝贵的历史经验。</p><p><strong>2.社会主义改造</strong><br>（1）农业手工业的社会主义改造：走互助合作道路。<br>（2）资本主义工商业的社会主义改造：和平赎买；低级到高级的国家资本主义过度形式，公私合营；成为自食其力的社会主义劳动者</p><h2 id="第四章-社会主义建设道路初步探索的理论成果"><a href="#第四章-社会主义建设道路初步探索的理论成果" class="headerlink" title="第四章 社会主义建设道路初步探索的理论成果"></a>第四章 社会主义建设道路初步探索的理论成果</h2><p><strong>两参一改三结合</strong> 干部参加劳动、工人参加管理，改革不合理规章制度，工人群众、领导干部、技术人员相结合<br><strong>《论十大关系》</strong> 党建设开端</p><p><strong>初步探索</strong> {总结第一个五年计划过程的经验；如何<strong>借鉴</strong>苏联社会建设的经验}<br><strong>借鉴意义</strong> 经济上：高度集中的计划经济体制；政治上：高度集权党的行政体制；对外关系上：严重的官僚主义</p><p><strong>三个主体三个补充</strong> （陈云提出）<br>（1）工商业经营方面：国家经济、集体经济是主体，个体经济是补充<br>（2）生产计划方面：计划生产是主体，许可范围内的自由生产是补充<br>（3）社会主义统一市场里：国家市场是主体，自由市场是补充</p><p><strong>1.党在中国社会主义建设道路的初步探索中取得了哪些重要的理论成果？</strong><br>（1）调动一切积极因素为社会主义事业服务的思想<br>（2）正确认识和处理社会主义矛盾的思想<br>（3）走中国工业化道路的思想<br>（4）初步探索的其他理论成果</p><p><strong>2.如何认识党对社会主义建设道路初步探索的重大意义？</strong><br>（1）巩固和发展了我国社会主义制度<br>（2）为开创中国特色社会之一提供了宝贵经验、理论准备、物质基础<br>（3）丰富了科学社会主义理论体系</p><p><strong>3.党对社会主义建设道路的初步探索有哪些经验教训？</strong><br>（1）必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义道路<br>（2）必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力<br>（3）必须从实际出发进行社会主义建设，不能急于求成<br>（4）必须发展社会主义民主，健全社会主义法制<br>（5）必须坚持党的民主集中制度和集体领导制度，加强执政党建设<br>（6）必须坚持对外开放</p><h2 id="第五章-邓小平理论"><a href="#第五章-邓小平理论" class="headerlink" title="第五章 邓小平理论"></a>第五章 邓小平理论</h2><ul><li><strong>时代背景</strong> 和平和发展成为时代主题</li><li><strong>1992 党的十四大</strong> 逐步形成和发展了建设<strong>有</strong>中国特色社会主义的理论</li><li><strong>1997 党的十五大</strong> 正式提出“邓小平理论”</li><li><strong>基本问题</strong> 什么是社会主义、怎样建设社会主义</li><li><strong>贯穿思想</strong> 解放思想、实事求是的思想路线</li></ul><p><strong>1.如何认识邓小平理论的形成的社会历史条件？</strong><br>（1）和平和发展成为时代主题<br>（2）总结我国社会主义胜利河挫折的历史经验<br>（3）借鉴其他社会主义国家兴衰成败历史经验<br>（4）在我国改革开放和现代化建设的实践中</p><p><strong>2.如何把握邓小平理论的主要内容？</strong><br>（1）解放思想，实事求是的思想<br>是党的思想路线。有力的推动和保障了改革开放的进行，体现了辩证唯物主义和历史唯物主义的世界观法论，体现了革命胆略和科学精神的统一，是邓小平理论的活的灵魂，是邓小平理论的精髓<br>（2）社会主义初级阶段理论<br>（3）党的基本路线<br>领导和团结各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，把为我国建设成为富强、民主、文明的社会主义现代化国家和奋斗。<br>（4）社会主义根本任务的理论<br>（5）“三步走”战略<br>第一步：1981-1990 实现国民生产总值比 1980 年翻一番，解决温饱问题；<br>第二步：1991-20 世纪末再翻一番，达到小康水平；<br>第三部：到 21 世纪，再翻两番，达到中等发达国家水平，基本实现现代化。<br>（6）改革开放理论<br>背景：国内“十月大革命”使党、国家、人民损失惨重；国际上科技、技术巨大落后<br>改革对象：对原有体制进行根本性变革<br>改革有利于：发展社会主义社会的生产力增强社会主义国家的综合国力；提高人民生活水平<br>（7）社会主义市场经济理论<br>推行家庭联产承包制，加速了农村经济市场化。先农村后城市，先试点后推广。<br>（8）两手抓，两手都要硬 （抓建设、抓法制）<br>（9）“一国两制”<br>是邓小平运用辩证唯物主义和历史唯物主义、坚持实事求是，把和平共处原则用于解决国家统一，体现原则性、灵活性，是对马克思主义国家学说的创造性发展。<br>（10）中国问题的关键在于党</p><p><strong>3.邓小平理论的历史地位？</strong><br>（1）是马克思列宁主义、毛泽东思想的继承和发展<br>（2）中国特色社会主义理论体系的开篇之作<br>（3）改革开放和社会主义现代化建设的科学指南</p><h2 id="第六章-“三个代表”重要思想"><a href="#第六章-“三个代表”重要思想" class="headerlink" title="第六章 “三个代表”重要思想"></a>第六章 “三个代表”重要思想</h2><p><strong>三个代表的核心观点</strong><br>（1）始终代表先进生产力的发展要求<br>（2）始终代表中国薪金文化的前进方向<br>（3）始终代表中国最广大人民的根本利益</p><p><strong>社会主义市场经济的重要性</strong><br>实现了改革开放新的历史性突破，打开了我国经济、政治和文化发展的崭新局面，是前无古人额伟大创举，是中国共产党人对马克思主义发展作出的历史性贡献，具有特殊的重要意义。</p><h2 id="第七章-科学发展观"><a href="#第七章-科学发展观" class="headerlink" title="第七章 科学发展观"></a>第七章 科学发展观</h2><p><strong>科学发展观的科学内涵</strong><br>科学发展观，第一要义是推动经济社会发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。这是对科学发展观的集中概括。</p><p><strong>科学发展观的精神实质</strong><br>解放思想、实事求是、与时俱进、求真务实</p><h2 id="第八章-习近平新时代中国国特色社会主义思想及其历史地位"><a href="#第八章-习近平新时代中国国特色社会主义思想及其历史地位" class="headerlink" title="第八章 习近平新时代中国国特色社会主义思想及其历史地位"></a>第八章 习近平新时代中国国特色社会主义思想及其历史地位</h2><p><strong>1.如何理解我国社会主要矛盾发生的变化？</strong><br>（1）新中国建立之初：广大人民群众同帝国主义、封建主义、国民党残余势力之间的矛盾<br>（2）1952 土地改革完成：无产阶级和资产阶级之间的矛盾<br>（3）社会主义改造基本完成后：人民日益增长的物质文化需要同落后的社会生产之间的矛盾<br>（4）十九大：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</p><p><strong>2.如何认识中国特色社会主义进入新时代？</strong><br>是我国发展新的历史方位。作出这个重大政治判断，是改革开放以来特别是党的十八大以来我国社会取得的历史性成就和发生的历史性变革的必然结果，是我国社会主要矛盾运动的必然结果，是党团结带领人民开创光明未来的必然要求。在中华人民共和国发展史上、中华民族发展史上具有重大意义，在世界社会主义发展史上也有重大意义。</p><p><strong>3.如何把握习近平新时代中国特色社会主义思想的主要内容和历史地位？</strong><br>主要内容围绕新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，提出了“八个明确”核心观点和“十四个坚持”进本方略。<br>是马克思主义中国化最新成果，是中国特色社会主义理论体系的重要组成部分，是当代中国马克思主义、21 世纪马克思主义，是党和国家必须长期坚持不断发展的指导思想，是全党全国人民为实现中华民族伟大复兴的行动指南。</p><h2 id="第九章-坚持和发展中国特色社会主义的总任务"><a href="#第九章-坚持和发展中国特色社会主义的总任务" class="headerlink" title="第九章 坚持和发展中国特色社会主义的总任务"></a>第九章 坚持和发展中国特色社会主义的总任务</h2><p><strong>三句诗</strong><br>习近平引用三句诗，生动诠释了近代以来中国人民寻梦、追梦、圆梦的历史进程。<br>（1）中华民族的昨天，“雄关漫道真如铁”<br>（2）今天，“人间正道是沧桑”<br>（3）明天，“长风破浪会有时”</p><p><strong>实现中华民族伟大复兴</strong>是近代以来中华民族最伟大的梦想<br><strong>中国梦的本质</strong> 国家富强、民族振兴、人民幸福</p><p><strong>1.如何看待开启全民建设社会主义现代化强国的新征程？</strong><br>提出“三步走”战略目标：小康社会—&gt;基本实现现代化—&gt;全面建成社会主义现代化强国。这一战略安排，是在综合分析国内形势和我国发展条件之后作出的重大决策安排，是我们党适应我国发展实际作出的必然选择，对动员全党全国各族人民万众一心实现中华民族伟大复兴的中国梦具有重大意义。</p><p><strong>两步走</strong>（在全面建成小康社会的基础上）<br>（1）从 2020 年到 2035 年，基本实现社会主义现代化的目标要求<br>（2）从 2035 年到本世纪中叶，建成社会主义现代化强国的目标要求</p><h2 id="第十章-“五位一体”总体布局"><a href="#第十章-“五位一体”总体布局" class="headerlink" title="第十章 “五位一体”总体布局"></a>第十章 “五位一体”总体布局</h2><p><strong>健全人民当家作主的制度体系</strong>是中国特色社会主义民主政治的最重要内容<br><strong>基本政治制度</strong> 以中国共产党领导的多党合作和政治协商制度（政党制度）、民族区域自治制度、基层群众自治制度<br><strong>根本自治制度</strong> 人民代表大会制度<br><strong>三结合</strong> 坚持党的领导、人民当家作主、依法治国偶有机统一</p><p>我国是<strong>工人阶级领导的、以工农联盟为基础的人民民主专政</strong>的社会主义国家</p><p><strong>1.新时代如何推进现代化经济体系建设？</strong><br>（1）贯彻创新、协调、绿色、开放、共享的新发展理念。<br>（2）深化供给侧结构性改革，坚持质量第一、效益优先，以供给侧结构性改革为主线，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率（总产量、全部要素投入量）。<br>推进增长动能转换，以加快发展先进制造业为重点全面提升实体经济；<br>深化要素市场化配置改革，实现由以价取胜向以质取胜的转变；<br>持续推进“三去一降一补”，优化市场供给结构。去产能、去库存、去杠杆、降成本、补短板；<br><strong>2.如何推动社会主义文化繁荣昌盛？</strong><br>（1）牢牢掌握意识形态工作领导权<br>（2）培育和践行社会主义核心价值观<br>（3）坚持文化自信，建设社会主义文化强国。提高文化软实力。</p><p><strong>3.如何在发展中加强和改善民生？</strong><br>（1）提高保障和改善民生水平。优先发展教育事业；提高就业质量和人民收入水平；坚决打赢脱贫攻坚战；实施健康中国战略。<br>（2）加强和创新社会治理<br>（3）坚持总体国家安全观。系统性、全面性、持续性。</p><p><strong>4.如何建设美丽中国？</strong><br>要树立人与自然和谐共生的基本理念，实现最严格的环境保护政策，坚持绿色发展，加快生态文明体制改革。<br>（1）坚持人与自然和谐共生。这是生态文明的核心。要尊重自然、顺应自然、保护自然<br>（2）形成人与自然和谐发展新格局<br>（3）加快生态文明体制改革</p><h2 id="第十一章-“四个全面”战略布局"><a href="#第十一章-“四个全面”战略布局" class="headerlink" title="第十一章 “四个全面”战略布局"></a>第十一章 “四个全面”战略布局</h2><p><strong>四个全面</strong> 全面建成小康社会、全面深化改革、全面依法治国、全面从严治党<br><strong>全面依法治国总目标</strong> 建设中国特色社会主义法治体系，建设社会主义法治国家<br><strong>党的十一届三中全会</strong> 明确提出“发展社会主义民主、健全社会主义法治”的重大方针<br><strong>十六大</strong> 提出发展社会主义民主政治，最根本的是要把坚持党的领导、人民当家作主和依法治国有机统一起来<br><strong>十七大</strong> 提出依法治国是社会主义民主政治的基本要求<br><strong>十八大</strong> 提出全面依法治国</p><p><strong>1.决胜全面建成小康社会提出了哪些要求？</strong><br>（1）坚决打好防范化解重大风险攻坚战<br>（2）坚决打好精准脱贫攻坚战<br>（3）坚决打好污染防治攻坚战<br>（4）确保经济社会持续健康发展</p><p><strong>2.如何理解全面深化改革的总目标？</strong>（党的十八届三中全会）<br>总目标是完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。</p><h2 id="第十三中-中国特色大国外交"><a href="#第十三中-中国特色大国外交" class="headerlink" title="第十三中 中国特色大国外交"></a>第十三中 中国特色大国外交</h2><p><strong>一带一路“五通”</strong> 政策沟通、设施沟通、贸易沟通、资金融通、民心相通</p><p><strong>1.如何认识当今世界的发展趋势？</strong><br>（1）世界正在处于大发展大变革大调整时期。和平和发展仍是时代主题，世界多极化、经济全球化、文化多样化、社会信息化、科学技术深入发展。各国相互联系和依存日益加深，和平发展大趋势不可逆转。同时，世界面临的不稳定性、不确定性突出。</p><p><strong>2.如何推动建立以互相尊重、公平正义、合作共赢为核心的新型国际关系？</strong><br>（1）坚决维护国家核心利益<br>（2）要在和平共处五项基本原则基础上发展同世界各国的友好合作<br>（3）要积极参与全球治理体系改革和建设<br>（4）要加强涉外法律工作<br>（5）要把相互尊重、公平正义、合作共赢理念体现到政治、经济、安全、文化等对外合作的方方面面，推动构建人类命运共同体。</p><p><strong>3.如何理解构建人类命运共同体思想的科学内涵？</strong><br>具有鲜明的时代背景，是一个科学完整、内涵丰富、意义深远的思想体系，其核心就是“建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界”。</p><p>==<strong>4.善于在危机中育先机，于变局中开新局</strong>==<br>我们要抓住机遇，应对挑战，趋利避害，奋勇前进。<br>第一，在危机中育先机，首先要看到危机并存、危中有机、危可转机，从而积极努力地去发现机遇、抓住机遇、塑造机遇。习近平总书记反复强调，危和机总是同生并存的，克服了危即是机。形势的剧烈变动往往是破旧立新、格局重塑的重要推手。当今世界正经历百年未有之大变局，对我们既有机遇也有挑战。<br>第二，于变局中开新局，就要善于准确识变、科学应变、主动求变，需要增强忧患意识，准确把握机遇和挑战的发展变化；重在防范化解重大风险，打好防范化解重大风险攻坚战；不断提高贯彻新发展理念、构建新发展格局的能力和水平。</p><h2 id="第十四章-坚持和加强党的领导"><a href="#第十四章-坚持和加强党的领导" class="headerlink" title="第十四章 坚持和加强党的领导"></a>第十四章 坚持和加强党的领导</h2><p><strong>中国共产党</strong> 是中国特色社会主义最本质的特征和制度的最大优势</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 毛概 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毛概 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
